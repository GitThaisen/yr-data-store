/* generated by Buddy */
if (window._m_ == null) window._m_ = {};
if (window.require == null) {
  window.require = function require (id) {
    if (!_m_[id]) return;
    return (_m_[id].boot) ? _m_[id]() : _m_[id];
  };
}
var global = window.global = window;

(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };
})(typeof global === "undefined" ? self : global);
_m_['is-plain-obj/index.js#1.1.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  var toString = Object.prototype.toString;
  
  module.exports = function (x) {
  	var prototype;
  	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
  };
  

  return module.exports;
}).call({exports:{}});
_m_['@yr/time/index.js#3.1.1']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Time utilities
   * https://github.com/yr/time
   * @copyright Yr
   * @license MIT
   */
  
  var isPlainObject = _m_['is-plain-obj/index.js#1.1.0'];
  
  var DEFAULT_DATE = 'Invalid Date';
  var DEFAULT_DAY_STARTS_AT = 0;
  var DEFAULT_NIGHT_STARTS_AT = 18;
  var DEFAULT_OFFSET = '+00:00';
  var DEFAULT_PARSE_KEYS = ['created', 'end', 'from', 'rise', 'set', 'start', 'times', 'to', 'update'];
  var FLAGS = {
    Y: 1,
    M: 2,
    D: 4,
    H: 8,
    m: 16,
    s: 32,
    S: 64
  };
  var FLAGS_START_OF = {
    Y: FLAGS.S | FLAGS.s | FLAGS.m | FLAGS.H | FLAGS.D | FLAGS.M,
    M: FLAGS.S | FLAGS.s | FLAGS.m | FLAGS.H | FLAGS.D,
    D: FLAGS.S | FLAGS.s | FLAGS.m | FLAGS.H,
    H: FLAGS.S | FLAGS.s | FLAGS.m,
    m: FLAGS.S | FLAGS.s,
    s: FLAGS.S
  };
  // YYYY-MM-DDTHH:mm:ss or YYYY-MM-DDTHH:mm:ss.SSSZ or YYYY-MM-DDTHH:mm:ss+00:00
  var RE_PARSE = /^(\d{2,4})-?(\d{1,2})?-?(\d{1,2})?T?(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?\.?(\d{3})?(?:Z|(([+-])(\d{2}):?(\d{2})))?$/;
  var RE_TOKEN = /(LTS?|L{1,4}|Y{4}|Y{2}|M{1,4}|D{1,2}|d{3}r|d{2}r|d{1,4}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|ZZ)/g;
  var RE_TOKEN_ESCAPE = /(\[[^\]]+\])/g;
  var RE_TOKEN_ESCAPED = /(\$\d\d?)/g;
  var dayStartsAt = DEFAULT_DAY_STARTS_AT;
  var nightStartsAt = DEFAULT_NIGHT_STARTS_AT;
  var parseKeys = DEFAULT_PARSE_KEYS;
  
  module.exports = {
    /**
     * Initialize with defaults
     * @param {Object} [options]
     */
  
    init: function init() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  
      dayStartsAt = options.dayStartsAt || DEFAULT_DAY_STARTS_AT;
      nightStartsAt = options.nightStartsAt || DEFAULT_NIGHT_STARTS_AT;
      parseKeys = options.parseKeys || DEFAULT_PARSE_KEYS;
    },
  
  
    /**
     * Instance factory
     * @param {String} timeString
     * @returns {Time}
     */
    create: function create(timeString) {
      return new Time(timeString);
    },
    now: function now() {
      return Date.now();
    },
  
  
    /**
     * Parse time strings into Time instances
     * @param {Object} obj
     * @returns {Object}
     */
    parse: function parse(obj) {
      function parseValue(value) {
        if (Array.isArray(value)) {
          return value.map(function (value) {
            return 'string' == typeof value ? new Time(value) : traverse(value);
          });
        } else if ('string' == typeof value) {
          return new Time(value);
        }
        return value;
      }
  
      function traverse(o) {
        // Abort if not object or array
        if (!(Array.isArray(o) || isPlainObject(o))) return o;
  
        for (var prop in o) {
          // Only parse whitelisted keys
          o[prop] = ~parseKeys.indexOf(prop) ? parseValue(o[prop]) : traverse(o[prop]);
        }
  
        return o;
      }
  
      return traverse(obj);
    },
  
  
    /**
     * Determine if 'time' is a Time instance
     * @param {Time} time
     * @returns {Boolean}
     */
    isTime: function isTime(time) {
      return time != null && time._manipulate != null && time._date != null;
    }
  };
  
  var Time = function () {
    /**
     * Constructor
     * @param {String} timeString
     */
  
    function Time(timeString) {
      babelHelpers.classCallCheck(this, Time);
  
      this._date = DEFAULT_DATE;
      this._locale = null;
      this._offset = 0;
      this._offsetString = DEFAULT_OFFSET;
      this.isValid = false;
      this.timeString = DEFAULT_DATE;
  
      // Local "now"
      if (timeString == null) {
        var d = new Date();
        var _offset = -1 * d.getTimezoneOffset();
  
        d.setUTCMinutes(d.getUTCMinutes() + _offset);
        timeString = d.toISOString().replace('Z', minutesToOffsetString(_offset));
      }
      // Prevent regex denial of service
      if (timeString.length > 30) return;
  
      var match = timeString.match(RE_PARSE);
  
      if (!match) return;
  
      var year = +match[1];
      var month = +match[2] || 1;
      var day = +match[3] || 1;
      var hour = +match[4] || 0;
      var minute = +match[5] || 0;
      var second = +match[6] || 0;
      var millisecond = +match[7] || 0;
      var offset = match[8] || '';
  
      // Handle TZ offset
      if (offset && offset != DEFAULT_OFFSET) {
        var dir = match[9] == '+' ? 1 : -1;
  
        this._offset = dir * (+match[10] * 60 + +match[11]);
        this._offsetString = offset;
      }
  
      // Create UTC date based on local time so we can always use UTC methods
      this._date = new Date(Date.UTC(year, month - 1, day, hour, minute, second, millisecond));
      this.isValid = isValid(this._date);
      this.timeString = this.toString();
    }
  
    /**
     * Add 'value' of 'unit' (years|months|days|hours|minutes|seconds|milliseconds)
     * Returns new instance
     * @param {Number} value
     * @param {String} unit
     * @returns {Time}
     */
  
  
    Time.prototype.add = function add(value, unit) {
      return this._manipulate(value, unit);
    };
  
    /**
     * Subtract 'value' of 'unit' (years|months|days|hours|minutes|seconds|milliseconds)
     * Returns new instance
     * @param {Number} value
     * @param {String} unit
     * @returns {Time}
     */
  
  
    Time.prototype.subtract = function subtract(value, unit) {
      return this._manipulate(value * -1, unit);
    };
  
    /**
     * Compute difference between 'time' of 'unit'
     * (from Moment.js)
     * @param {Time} time
     * @param {String} unit
     * @param {Boolean} [asFloat]
     * @returns {Number}
     */
  
  
    Time.prototype.diff = function diff(time, unit, asFloat) {
      if (!this.isValid) return NaN;
      if (!time.isValid) return NaN;
  
      unit = normalizeUnit(unit);
  
      var diff = 0;
      var t1 = this;
      var t2 = time;
  
      if (unit == 'Y' || unit == 'M') {
        diff = t1._monthDiff(t2);
        if (unit == 'Y') diff /= 12;
      } else {
        // Correct for custom day start
        if (unit == 'D' && !asFloat) {
          t1 = t1.startOf('D');
          t2 = t2.startOf('D');
        }
  
        var delta = t1._date - t2._date;
  
        switch (unit) {
          case 'D':
            diff = delta / 864e5;
            break;
          case 'H':
            diff = delta / 36e5;
            break;
          case 'm':
            diff = delta / 6e4;
            break;
          case 's':
            diff = delta / 1e3;
            break;
          default:
            diff = delta;
        }
      }
  
      return asFloat ? diff : round(diff);
    };
  
    /**
     * Reset to start of 'unit'
     * Returns new instance
     * @param {String} unit
     * @returns {Time}
     */
  
  
    Time.prototype.startOf = function startOf(unit) {
      if (this.isValid) {
        unit = normalizeUnit(unit);
  
        var flags = FLAGS_START_OF[unit];
        var instance = this.clone();
        var d = instance._date;
  
        for (var dim in FLAGS) {
          if (flags & FLAGS[dim]) {
            switch (dim) {
              case 'M':
                d.setUTCMonth(0);
                break;
              case 'D':
                d.setUTCDate(1);
                break;
              case 'H':
                // Adjust day if less than day start hour
                if (unit == 'D' && dayStartsAt > d.getUTCHours()) d.setUTCDate(d.getUTCDate() - 1);
                d.setUTCHours(dayStartsAt);
                break;
              case 'm':
                d.setUTCMinutes(0);
                break;
              case 's':
                d.setUTCSeconds(0);
                break;
              case 'S':
                d.setUTCMilliseconds(0);
                break;
            }
          }
        }
  
        return update(instance);
      }
  
      return this;
    };
  
    /**
     * Get/set full year
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.year = function year(value) {
      if (value != null) return this._set(value, 'setUTCFullYear');
      return this._date.getUTCFullYear();
    };
  
    /**
     * Get/set month (0-11)
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.month = function month(value) {
      if (value != null) return this._set(value, 'setUTCMonth');
      return this._date.getUTCMonth();
    };
  
    /**
     * Get/set date (1-31)
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.date = function date(value) {
      if (value != null) return this._set(value, 'setUTCDate');
      return this._date.getUTCDate();
    };
  
    /**
     * Retrieve day of week (0-6)
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.day = function day(value) {
      var day = this._date.getUTCDay();
  
      if (value != null) return this._set(this.date() + value - day, 'setUTCDate');
      return day;
    };
  
    /**
     * Get/set hour (0-23)
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.hour = function hour(value) {
      if (value != null) return this._set(value, 'setUTCHours');
      return this._date.getUTCHours();
    };
  
    /**
     * Get/set minute (0-59)
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.minute = function minute(value) {
      if (value != null) return this._set(value, 'setUTCMinutes');
      return this._date.getUTCMinutes();
    };
  
    /**
     * Get/set second (0-59)
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.second = function second(value) {
      if (value != null) return this._set(value, 'setUTCSeconds');
      return this._date.getUTCSeconds();
    };
  
    /**
     * Get/set millisecond (0-999)
     * Returns new instance when setting
     * @param {Number} [value]
     * @returns {Number|Time}
     */
  
  
    Time.prototype.millisecond = function millisecond(value) {
      if (value != null) return this._set(value, 'setUTCMilliseconds');
      return this._date.getUTCMilliseconds();
    };
  
    /**
     * Compare 'time', limited by 'unit', and determine if is similar
     * @param {Time} time
     * @param {String} [unit]
     * @returns {Boolean}
     */
  
  
    Time.prototype.isSame = function isSame(time, unit) {
      if (!this.isValid || !time.isValid) return false;
  
      unit = normalizeUnit(unit);
  
      if (!unit || unit == 'S') return +this._date === +time._date;
  
      var t1 = this;
      var t2 = time;
  
      // Correct for custom day start
      if (unit == 'D') {
        t1 = t1.startOf(unit);
        t2 = t2.startOf(unit);
      }
  
      switch (unit) {
        case 'Y':
          return t1.year() == t2.year();
        case 'M':
          return t1.year() == t2.year() && t1.month() == t2.month();
        case 'D':
          return t1.year() == t2.year() && t1.month() == t2.month() && t1.date() == t2.date();
        case 'H':
          return t1.year() == t2.year() && t1.month() == t2.month() && t1.date() == t2.date() && t1.hour() == t2.hour();
        case 'm':
          return t1.year() == t2.year() && t1.month() == t2.month() && t1.date() == t2.date() && t1.hour() == t2.hour() && t1.minute() == t2.minute();
        case 's':
          return t1.year() == t2.year() && t1.month() == t2.month() && t1.date() == t2.date() && t1.hour() == t2.hour() && t1.minute() == t2.minute() && t1.second() == t2.second();
      }
    };
  
    /**
     * Compare 'time', limited by 'unit', and determine if is before
     * @param {Time} time
     * @param {String} [unit]
     * @returns {Boolean}
     */
  
  
    Time.prototype.isBefore = function isBefore(time, unit) {
      if (!this.isValid || !time.isValid) return false;
  
      unit = normalizeUnit(unit);
  
      if (!unit || unit == 'S') return +this._date < +time._date;
  
      var Y1 = this.year();
      var Y2 = time.year();
      var M1 = this.month();
      var M2 = time.month();
      var D1 = this.date();
      var D2 = time.date();
      var H1 = this.hour();
      var H2 = time.hour();
      var m1 = this.minute();
      var m2 = time.minute();
      var s1 = this.second();
      var s2 = time.second();
      var test = false;
  
      test = Y1 > Y2;
      if (unit == 'Y') return test;
      test = test || Y1 == Y2 && M1 > M2;
      if (unit == 'M') return test;
      test = test || M1 == M2 && D1 > D2;
      if (unit == 'D') return test;
      test = test || D1 == D2 && H1 > H2;
      if (unit == 'H') return test;
      test = test || H1 == H2 && m1 > m2;
      if (unit == 'm') return test;
      test = test || m1 == m2 && s1 > s2;
  
      return test;
    };
  
    /**
     * Set 'locale'
     * @param {Object} locale
     * @returns {Time}
     */
  
  
    Time.prototype.locale = function locale(_locale) {
      var instance = this.clone();
  
      instance._locale = _locale;
      return instance;
    };
  
    /**
     * Format into string based on 'mask'
     * @param {String} mask
     * @param {Number} [daysFromNow]
     * @returns {String}
     */
  
  
    Time.prototype.format = function format(mask, daysFromNow) {
      var _this = this;
  
      if (!mask) return this.timeString;
      // Prevent regex denial of service
      if (mask.length > 100) return '';
  
      var relativeDay = daysFromNow != null ? this._getRelativeDay(daysFromNow) : '';
      var escaped = [];
      var idx = 0;
  
      // Remove all escaped text (in [xxx])
      mask = mask.replace(RE_TOKEN_ESCAPE, function (match) {
        escaped.push(match.slice(1, -1));
        return '$' + idx++;
      });
  
      mask = mask.replace(RE_TOKEN, function (match) {
        switch (match) {
          case 'LT':
          case 'LTS':
          case 'L':
          case 'LL':
          case 'LLL':
          case 'LLLL':
            return _this._locale && _this._locale.format && _this._locale.format[match] ? _this.format(_this._locale.format[match], daysFromNow) : '[missing locale]';
          case 'YY':
            return String(_this.year()).slice(-2);
          case 'YYYY':
            return _this.year();
          case 'M':
            return _this.month() + 1;
          case 'MM':
            return pad(_this.month() + 1);
          case 'MMM':
            return _this._locale && _this._locale.monthsShort ? _this._locale.monthsShort[_this.month()] : '[missing locale]';
          case 'MMMM':
            return _this._locale && _this._locale.months ? _this._locale.months[_this.month()] : '[missing locale]';
          case 'D':
            return _this.date();
          case 'DD':
            return pad(_this.date());
          case 'ddr':
            if (relativeDay) return _this._locale && _this._locale[relativeDay] ? _this._locale[relativeDay] : '[missing locale]';
            return _this._locale && _this._locale.daysShort ? _this._locale.daysShort[_this.day()] : '[missing locale]';
          case 'dddr':
            if (relativeDay) return _this._locale && _this._locale[relativeDay] ? _this._locale[relativeDay] : '[missing locale]';
            return _this._locale && _this._locale.days ? _this._locale.days[_this.day()] : '[missing locale]';
          case 'd':
            return _this.day();
          case 'ddd':
            return _this._locale && _this._locale.daysShort ? _this._locale.daysShort[_this.day()] : '[missing locale]';
          case 'dddd':
            return _this._locale && _this._locale.days ? _this._locale.days[_this.day()] : '[missing locale]';
          case 'H':
            return _this.hour();
          case 'HH':
            return pad(_this.hour());
          case 'm':
            return _this.minute();
          case 'mm':
            return pad(_this.minute());
          case 's':
            return _this.second();
          case 'ss':
            return pad(_this.second());
          case 'S':
            return Math.floor(_this.millisecond() / 100);
          case 'SS':
            return Math.floor(_this.millisecond() / 10);
          case 'SSS':
            return _this.millisecond();
          case 'ZZ':
            return _this._offsetString;
          default:
            return '';
        }
      });
  
      // Replace all escaped text
      if (escaped.length) {
        mask = mask.replace(RE_TOKEN_ESCAPED, function (match) {
          return escaped[match.slice(1)];
        });
      }
  
      return mask;
    };
  
    /**
     * Return instance at UTC time
     * @returns {Time}
     */
  
  
    Time.prototype.utc = function utc() {
      if (!this._offset) return this.clone();
  
      var t = this.subtract(this._offset, 'minutes');
  
      t._offset = 0;
      t._offsetString = DEFAULT_OFFSET;
      return update(t);
    };
  
    /**
     * Clone instance
     * @returns {Time}
     */
  
  
    Time.prototype.clone = function clone() {
      var instance = new Time(this.timeString);
  
      instance._locale = this._locale;
      return instance;
    };
  
    /**
     * Set 'value' using 'method'
     * Returns new instance
     * @param {Number} value
     * @param {String} method
     * @returns {Time}
     */
  
  
    Time.prototype._set = function _set(value, method) {
      var instance = this.clone();
      var d = instance._date;
  
      d[method](value);
      return update(instance);
    };
  
    /**
     * Retrieve relative day type based on number of days from "now"
     * @param {Number} daysFromNow
     * @returns {String}
     */
  
  
    Time.prototype._getRelativeDay = function _getRelativeDay(daysFromNow) {
      if (daysFromNow != null && daysFromNow < 2) {
        var hour = this.hour();
  
        return daysFromNow == 1 ? 'tomorrow' : hour >= nightStartsAt || hour < dayStartsAt ? 'tonight' : 'today';
      }
      return '';
    };
  
    /**
     * Add/subtract 'value' in 'unit'
     * Returns new instance
     * @param {Number} value
     * @param {String} unit
     * @returns {Time}
     */
  
  
    Time.prototype._manipulate = function _manipulate(value, unit) {
      if (this.isValid) {
        var instance = this.clone();
        var d = instance._date;
  
        switch (normalizeUnit(unit)) {
          case 'Y':
            d.setUTCFullYear(d.getUTCFullYear() + value);
            break;
          case 'M':
            d.setUTCMonth(d.getUTCMonth() + value);
            break;
          case 'D':
          case 'd':
            d.setUTCDate(d.getUTCDate() + value);
            break;
          case 'H':
            d.setUTCHours(d.getUTCHours() + value);
            break;
          case 'm':
            d.setUTCMinutes(d.getUTCMinutes() + value);
            break;
          case 's':
            d.setUTCSeconds(d.getUTCSeconds() + value);
            break;
          case 'S':
            d.setUTCMilliseconds(s.getUTCMilliseconds() + value);
            break;
        }
  
        return update(instance);
      }
  
      return this;
    };
  
    /**
     * Compute difference between 'time' in months
     * (from Moment.js)
     * @param {Time} time
     * @returns {Number}
     */
  
  
    Time.prototype._monthDiff = function _monthDiff(time) {
      var wholeMonthDiff = (time._date.getUTCFullYear() - this._date.getUTCFullYear()) * 12 + (time._date.getUTCMonth() - this._date.getUTCMonth());
      var anchor = this._manipulate(wholeMonthDiff, 'M');
      var adjust = void 0;
  
      if (time._date - anchor._date < 0) {
        var anchor2 = this._manipulate(wholeMonthDiff - 1, 'M');
  
        adjust = (time._date - anchor._date) / (anchor._date - anchor2._date);
      } else {
        var _anchor = this._manipulate(wholeMonthDiff + 1, 'M');
  
        adjust = (time._date - anchor._date) / (_anchor._date - anchor._date);
      }
  
      return -(wholeMonthDiff + adjust);
    };
  
    /**
     * Retrieve stringified
     * @returns {String}
     */
  
  
    Time.prototype.toString = function toString() {
      if (!this.isValid) return 'Invalid Date';
      return this._date.toISOString().replace('Z', this._offsetString);
    };
  
    /**
     * Convert to JSON format
     * @returns {String}
     */
  
  
    Time.prototype.toJSON = function toJSON() {
      return this.timeString;
    };
  
    /**
     * Retrieve number of milliseconds UTC
     * @returns {Number}
     */
  
  
    Time.prototype.valueOf = function valueOf() {
      if (!this.isValid) return NaN;
      return +this._date;
    };
  
    return Time;
  }();
  
  /**
   * Update 'instance' state
   * @param {Time} instance
   * @returns {Time}
   */
  
  
  function update(instance) {
    instance.isValid = isValid(instance._date);
    instance.timeString = instance.toString();
    return instance;
  }
  
  /**
   * Normalize 'unit'
   * @param {Strong} unit
   * @returns {String}
   */
  function normalizeUnit(unit) {
    switch (unit) {
      case 'year':
      case 'years':
      case 'Y':
      case 'y':
        return 'Y';
      case 'month':
      case 'months':
      case 'M':
        return 'M';
      case 'day':
      case 'days':
      case 'date':
      case 'dates':
      case 'D':
      case 'd':
        return 'D';
      case 'hour':
      case 'hours':
      case 'H':
      case 'h':
        return 'H';
      case 'minute':
      case 'minutes':
      case 'm':
        return 'm';
      case 'second':
      case 'seconds':
      case 's':
        return 's';
      case 'millisecond':
      case 'milliseconds':
      case 'S':
        return 'S';
    }
    return unit;
  }
  
  /**
   * Validate 'date' object
   * @param {Date} date
   * @returns {Boolean}
   */
  function isValid(date) {
    return Object.prototype.toString.call(date) == '[object Date]' && !isNaN(date.getTime());
  }
  
  /**
   * Round 'value' towards 0
   * @param {Number} value
   * @returns {Number}
   */
  function round(value) {
    if (value < 0) return Math.ceil(value);
    return Math.floor(value);
  }
  
  /**
   * Pad 'value' with zeros up to desired 'length'
   * @param {String|Number} value
   * @param {Number} length
   * @returns {String}
   */
  function pad(value, length) {
    value = String(value);
    length = length || 2;
  
    while (value.length < length) {
      value = '0' + value;
    }
  
    return value;
  }
  
  /**
   * Convert 'minutes' to offset string
   * @param {Number} minutes
   * @returns {String}
   */
  function minutesToOffsetString(minutes) {
    var t = String(Math.abs(minutes / 60)).split('.');
    var H = pad(t[0]);
    var m = t[1] ? parseInt(t[1], 10) * 0.6 : 0;
    var sign = minutes < 0 ? '-' : '+';
  
    return '' + sign + H + ':' + pad(m);
  }

  return module.exports;
}).call({exports:{}});
_m_['@yr/runtime/index.js#1.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Determine if the current runtime is server or browser
   * https://github.com/yr/runtime
   * @copyright Yr
   * @license MIT
   */
  
  var isNode = (typeof process !== 'undefined'
    && {}.toString.call(process) === '[object process]');
  
  exports.isServer = isNode;
  exports.isBrowser = !isNode;

  return module.exports;
}).call({exports:{}});
_m_['@yr/property/lib/needsMerge.js#3.1.5']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  var isPlainObject = _m_['is-plain-obj/index.js#1.1.0'];
  
  /**
   * Test if 'value' should be merged into 'obj' at 'key'
   * @param {String} key
   * @param {Object} value
   * @param {Object} obj
   * @returns {Boolean}
   */
  module.exports = function needsMerge(key, value, obj) {
    return key in obj && isPlainObject(obj[key]) && isPlainObject(value);
  };

  return module.exports;
}).call({exports:{}});
_m_['@yr/property/lib/clone.js#3.1.5']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  var isPlainObject = _m_['is-plain-obj/index.js#1.1.0'];
  
  /**
   * Shallow clone 'value' if it's an array or plain object
   * @param {Object|Array|Number|String} value
   * @returns {Object|Array|Number|String}
   */
  module.exports = function clone(value) {
    if (value != null) {
      if (Array.isArray(value)) {
        return value.slice();
      }
  
      if (isPlainObject(value)) {
        var obj = {};
  
        for (var prop in value) {
          // Copy own properties
          if (value.hasOwnProperty(prop)) {
            obj[prop] = value[prop];
          }
        }
  
        return obj;
      }
    }
  
    return value;
  };

  return module.exports;
}).call({exports:{}});
_m_['@yr/property/lib/write.js#3.1.5']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  var clone = _m_['@yr/property/lib/clone.js#3.1.5'];
  var needsMerge = _m_['@yr/property/lib/needsMerge.js#3.1.5'];
  
  /**
   * Write 'value' at 'key' of 'obj'
   * Handles merging of object properties if necessary
   * @param {String} key
   * @param {Object} value
   * @param {Object} obj
   * @param {Boolean} merge
   * @returns {Boolean}
   */
  module.exports = function write(key, value, obj, merge) {
    var mutated = false;
  
    // Don't write if values are the same
    if (obj[key] !== value) {
      // Merge with existing if both objects (not array)
      if (merge && needsMerge(key, value, obj)) {
        // Merged object must be unique, regardless of immutability
        obj[key] = clone(obj[key]);
        for (var k in value) {
          // Only write if not equal
          if (obj[key][k] !== value[k]) {
            obj[key][k] = value[k];
            mutated = true;
          }
        }
  
        // Overwrite
      } else if (obj[key] !== value) {
          obj[key] = value;
          mutated = true;
        }
    }
  
    return mutated;
  };

  return module.exports;
}).call({exports:{}});
_m_['@yr/property/index.js#3.1.5']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * Generic utility for getting/setting properties of an object
   * https://github.com/yr/property
   * @copyright Yr
   * @license MIT
   */
  
  var clone = _m_['@yr/property/lib/clone.js#3.1.5'];
  var isPlainObject = _m_['is-plain-obj/index.js#1.1.0'];
  var needsMerge = _m_['@yr/property/lib/needsMerge.js#3.1.5'];
  var write = _m_['@yr/property/lib/write.js#3.1.5'];
  
  exports.separator = '/';
  
  /**
   * Retrieve value for 'key' of 'obj'
   * @param {String} key
   *    can be nested keys of type 'foo/bar'
   * @param {Object} obj
   * @returns {Object}
   */
  exports.get = function (key, obj) {
    if ('string' == typeof key) {
      // Return all if empty key
      if (key == '') return obj;
  
      // Not nested
      if (! ~key.indexOf(exports.separator)) return obj[key];
  
      var keys = key.split(exports.separator);
      var found = true;
      var idx = 0;
  
      // Walk property chain
      while (idx < keys.length) {
        if (found) {
          if (obj[keys[idx]] == null) found = false;
          obj = obj[keys[idx]];
        }
        idx++;
      }
  
      return found ? obj : null;
    }
  
    return null;
  };
  
  /**
   * Store 'value' at 'key' of 'obj'.
   * Returns false if no change, and new object if 'immutable', or original if not
   * @param {String} key
   * 		can be nested keys of type 'foo/bar'
   * @param {Object} value
   * @param {Object} obj
   * @param {Object} options
   * 		default is false
   * @returns {Object|Boolean}
   */
  exports.set = function (key, value, obj, options) {
    // Default options
    options = options || {
      immutable: false,
      merge: true
    };
    if (options.merge == null) options.merge = true;
  
    var mutated = false;
  
    if (key && 'string' == typeof key) {
      // Copy root node
      if (options.immutable) obj = clone(obj);
      // Not nested
      if (! ~key.indexOf(exports.separator)) {
        // Create new copy if we are merging props
        if (options.immutable && needsMerge(key, value, obj)) obj[key] = clone(obj[key]);
        mutated = write(key, value, obj, options.merge);
      } else {
        var keys = key.split(exports.separator);
        var ref = obj;
        var idx = 0;
  
        while (idx < keys.length - 1) {
          // Clone each parent object in keychain
          if (options.immutable) ref[keys[idx]] = clone(ref[keys[idx]]);
          // Create object if it doesn't exist or overwrite if it does
          if (ref[keys[idx]] == null || !isPlainObject(ref[keys[idx]])) {
            ref[keys[idx]] = {};
          }
          ref = ref[keys[idx]];
          idx++;
        }
  
        mutated = write(keys[idx], value, ref, options.merge);
      }
  
      return mutated ? obj : null;
    }
  };
  
  /**
   * Flatten 'obj' down 'n' levels and return collection with
   * flattended properties as key for object.
   * @param {Object} obj
   * @param {Number} n
   * @returns {Object}
   */
  exports.flatten = function (obj, n) {
    n = n || 0;
  
    var collection = {};
  
    function walk(obj, key, idx) {
      if (idx == 0) {
        collection[key] = obj;
        return;
      }
  
      var keyChain = '';
  
      for (var prop in obj) {
        keyChain = key ? key + exports.separator + prop : prop;
        if (isPlainObject(obj[prop])) {
          walk(obj[prop], keyChain, idx - 1);
        } else {
          collection[keyChain] = obj[prop];
        }
      }
    }
  
    if (n > 0) {
      walk(obj, '', n + 1);
    } else {
      collection = obj;
    }
  
    return collection;
  };

  return module.exports;
}).call({exports:{}});
_m_['@yr/keys/index.js#1.1.2']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * String/keys utilities
   * https://github.com/yr/keys
   * @copyright Yr
   * @license MIT
   */
  
  exports.separator = '/';
  
  /**
   * Retrieve segments of 'key' based on slice indexes 'begin' and 'end'
   * @param {String} key
   * @param {Number} begin
   * @param {Number} [end]
   * @returns {String}
   */
  exports.slice = function slice(key, begin, end) {
    if (!key || 'string' != typeof key) return key;
  
    var leading = '';
  
    if (key.charAt(0) == exports.separator) {
      key = key.slice(1);
      // Store if slicing from beginning
      leading = begin == 0 ? exports.separator : '';
    }
  
    var segs = key.split(exports.separator);
  
    return leading + segs.slice(begin, end).join(exports.separator);
  };
  
  /**
   * Retrieve first segment of 'key'
   * @param {String} key
   * @returns {String}
   */
  exports.first = function first(key) {
    return exports.slice(key, 0, 1);
  };
  
  /**
   * Retrieve last segment of 'key'
   * @param {String} key
   * @returns {String}
   */
  exports.last = function last(key) {
    return exports.slice(key, -1);
  };
  
  /**
   * Retrieve number of key segments
   * @param {String} key
   * @returns {Number}
   */
  exports.length = function length(key) {
    if ('string' != typeof key) return 0;
  
    // Trim leading '/'
    if (key.charAt(0) == exports.separator) key = key.slice(1);
  
    if (!key) return 0;
  
    return key.split(exports.separator).length;
  };
  
  /**
   * Join '...keys' with exports.separator
   * @returns {String}
   */
  exports.join = function join() {
    for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }
  
    var key = keys[0];
  
  
    for (var i = 1, n = keys.length; i < n; i++) {
      var k = keys[i];
      if (k !== null && k !== undefined && k !== '' && k !== exports.separator) {
        // Handle numbers
        k = String(k);
        // Add leading slash for subsequent keys
        if (key.charAt(key.length - 1) != exports.separator && k.charAt(0) != exports.separator) {
          key += exports.separator;
        }
        key += k;
      }
    }
  
    return key;
  };
  
  /**
   * Merge '...keys' with exports.separator
   * taking care of overlaps
   * @returns {String}
   */
  exports.merge = function merge() {
    var _exports;
  
    var keySegments = [];
    var k = void 0,
        idx = void 0,
        len = void 0,
        segs = void 0;
  
    for (var _len2 = arguments.length, keys = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }
  
    for (var i = 0, n = keys.length; i < n; i++) {
      if (k = keys[i]) {
        len = keySegments.length;
  
        // Strip leading '/'
        if (k.charAt(0) == exports.separator) {
          k = k.slice(1);
          // Store if first key
          if (!len) {
            keySegments.push(exports.separator);
            len++;
          }
        }
  
        segs = k.split(exports.separator);
        idx = len ? segs.indexOf(keySegments[len - 1]) : -1;
        // No overlap
        if (!len || idx > len || idx == -1) {
          keySegments = keySegments.concat(segs);
          // Overlap
        } else {
            for (var j = idx; j >= 0; j--) {
              // No match
              if (segs[j] != keySegments[len - 1 - (idx - j)]) break;
              // Matched up to beginning, so slice
              if (j == 0) segs = segs.slice(idx + 1);
            }
            keySegments = keySegments.concat(segs);
          }
      }
    }
  
    return (_exports = exports).join.apply(_exports, keySegments);
  };
  
  /**
   * Escape 'key' segment separators
   * @param {String} key
   * @returns {String}
   */
  exports.escape = function escape(key) {
    return key.replace(/\//g, '___');
  };
  
  /**
   * Unescape escaped 'key' segment separators
   * @param {String} key
   * @returns {String}
   */
  exports.unescape = function unescape(key) {
    return key.replace(/___/g, exports.separator);
  };

  return module.exports;
}).call({exports:{}});
_m_['eventemitter3/index.js#1.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  var has = Object.prototype.hasOwnProperty;
  
  //
  // We store our EE objects in a plain object whose properties are event names.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // `~` to make sure that the built-in object properties are not overridden or
  // used as an attack vector.
  // We also assume that `Object.create(null)` is available when the event name
  // is an ES6 Symbol.
  //
  var prefix = typeof Object.create !== 'function' ? '~' : false;
  
  /**
   * Representation of a single EventEmitter function.
   *
   * @param {Function} fn Event handler to be called.
   * @param {Mixed} context Context for function execution.
   * @param {Boolean} [once=false] Only emit once
   * @api private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  
  /**
   * Minimal EventEmitter interface that is molded against the Node.js
   * EventEmitter interface.
   *
   * @constructor
   * @api public
   */
  function EventEmitter() { /* Nothing to set */ }
  
  /**
   * Hold the assigned EventEmitters by name.
   *
   * @type {Object}
   * @private
   */
  EventEmitter.prototype._events = undefined;
  
  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @api public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var events = this._events
      , names = []
      , name;
  
    if (!events) return names;
  
    for (name in events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
  
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
  
    return names;
  };
  
  /**
   * Return a list of assigned event listeners.
   *
   * @param {String} event The events that should be listed.
   * @param {Boolean} exists We only need to know if there are listeners.
   * @returns {Array|Boolean}
   * @api public
   */
  EventEmitter.prototype.listeners = function listeners(event, exists) {
    var evt = prefix ? prefix + event : event
      , available = this._events && this._events[evt];
  
    if (exists) return !!available;
    if (!available) return [];
    if (available.fn) return [available.fn];
  
    for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
      ee[i] = available[i].fn;
    }
  
    return ee;
  };
  
  /**
   * Emit an event to all registered event listeners.
   *
   * @param {String} event The name of the event.
   * @returns {Boolean} Indication if we've emitted an event.
   * @api public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events || !this._events[evt]) return false;
  
    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;
  
    if ('function' === typeof listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
  
      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
  
      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
  
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;
  
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
  
        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
  
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
  
    return true;
  };
  
  /**
   * Register a new EventListener for the given event.
   *
   * @param {String} event Name of the event.
   * @param {Function} fn Callback function.
   * @param {Mixed} [context=this] The context of the function.
   * @api public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    var listener = new EE(fn, context || this)
      , evt = prefix ? prefix + event : event;
  
    if (!this._events) this._events = prefix ? {} : Object.create(null);
    if (!this._events[evt]) this._events[evt] = listener;
    else {
      if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [
        this._events[evt], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Add an EventListener that's only called once.
   *
   * @param {String} event Name of the event.
   * @param {Function} fn Callback function.
   * @param {Mixed} [context=this] The context of the function.
   * @api public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    var listener = new EE(fn, context || this, true)
      , evt = prefix ? prefix + event : event;
  
    if (!this._events) this._events = prefix ? {} : Object.create(null);
    if (!this._events[evt]) this._events[evt] = listener;
    else {
      if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [
        this._events[evt], listener
      ];
    }
  
    return this;
  };
  
  /**
   * Remove event listeners.
   *
   * @param {String} event The event we want to remove.
   * @param {Function} fn The listener that we need to find.
   * @param {Mixed} context Only remove listeners matching this context.
   * @param {Boolean} once Only remove once listeners.
   * @api public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
  
    if (!this._events || !this._events[evt]) return this;
  
    var listeners = this._events[evt]
      , events = [];
  
    if (fn) {
      if (listeners.fn) {
        if (
             listeners.fn !== fn
          || (once && !listeners.once)
          || (context && listeners.context !== context)
        ) {
          events.push(listeners);
        }
      } else {
        for (var i = 0, length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
      }
    }
  
    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) {
      this._events[evt] = events.length === 1 ? events[0] : events;
    } else {
      delete this._events[evt];
    }
  
    return this;
  };
  
  /**
   * Remove all listeners or only the listeners for the specified event.
   *
   * @param {String} event The event want to remove all listeners for.
   * @api public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    if (!this._events) return this;
  
    if (event) delete this._events[prefix ? prefix + event : event];
    else this._events = prefix ? {} : Object.create(null);
  
    return this;
  };
  
  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  
  //
  // This function doesn't apply anymore.
  //
  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
    return this;
  };
  
  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;
  
  //
  // Expose the module.
  //
  if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
  }
  

  return module.exports;
}).call({exports:{}});
_m_['ms/index.js#0.7.1']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * Helpers.
   */
  
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} options
   * @return {String|Number}
   * @api public
   */
  
  module.exports = function(val, options){
    options = options || {};
    if ('string' == typeof val) return parse(val);
    return options.long
      ? long(val)
      : short(val);
  };
  
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */
  
  function parse(str) {
    str = '' + str;
    if (str.length > 10000) return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function short(ms) {
    if (ms >= d) return Math.round(ms / d) + 'd';
    if (ms >= h) return Math.round(ms / h) + 'h';
    if (ms >= m) return Math.round(ms / m) + 'm';
    if (ms >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function long(ms) {
    return plural(ms, d, 'day')
      || plural(ms, h, 'hour')
      || plural(ms, m, 'minute')
      || plural(ms, s, 'second')
      || ms + ' ms';
  }
  
  /**
   * Pluralization helper.
   */
  
  function plural(ms, n, name) {
    if (ms < n) return;
    if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  

  return module.exports;
}).call({exports:{}});
_m_['debug/debug.js#2.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = _m_['ms/index.js#0.7.1'];
  
  /**
   * The currently active debug mode names, and names to skip.
   */
  
  exports.names = [];
  exports.skips = [];
  
  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lowercased letter, i.e. "n".
   */
  
  exports.formatters = {};
  
  /**
   * Previously assigned color.
   */
  
  var prevColor = 0;
  
  /**
   * Previous log timestamp.
   */
  
  var prevTime;
  
  /**
   * Select a color.
   *
   * @return {Number}
   * @api private
   */
  
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  
  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */
  
  function debug(namespace) {
  
    // define the `disabled` version
    function disabled() {
    }
    disabled.enabled = false;
  
    // define the `enabled` version
    function enabled() {
  
      var self = enabled;
  
      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
  
      // add the `color` if not set
      if (null == self.useColors) self.useColors = exports.useColors();
      if (null == self.color && self.useColors) self.color = selectColor();
  
      var args = Array.prototype.slice.call(arguments);
  
      args[0] = exports.coerce(args[0]);
  
      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %o
        args = ['%o'].concat(args);
      }
  
      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
  
          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });
  
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
  
    var fn = exports.enabled(namespace) ? enabled : disabled;
  
    fn.namespace = namespace;
  
    return fn;
  }
  
  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */
  
  function enable(namespaces) {
    exports.save(namespaces);
  
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
  
    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  
  /**
   * Disable debug output.
   *
   * @api public
   */
  
  function disable() {
    exports.enable('');
  }
  
  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */
  
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */
  
  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
  

  return module.exports;
}).call({exports:{}});
_m_['debug/browser.js#2.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */
  
  exports = module.exports = _m_['debug/debug.js#2.2.0'];
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome
                 && 'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage();
  
  /**
   * Colors.
   */
  
  exports.colors = [
    'lightseagreen',
    'forestgreen',
    'goldenrod',
    'dodgerblue',
    'darkorchid',
    'crimson'
  ];
  
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  
  function useColors() {
    // is webkit? http://stackoverflow.com/a/16459606/376773
    return ('WebkitAppearance' in document.documentElement.style) ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      (window.console && (console.firebug || (console.exception && console.table))) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */
  
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  
  
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */
  
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
  
    args[0] = (useColors ? '%c' : '')
      + this.namespace
      + (useColors ? ' %c' : ' ')
      + args[0]
      + (useColors ? '%c ' : ' ')
      + '+' + exports.humanize(this.diff);
  
    if (!useColors) return args;
  
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
  
    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
  
    args.splice(lastC, 0, c);
    return args;
  }
  
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */
  
  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
  
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch(e) {}
  }
  
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch(e) {}
    return r;
  }
  
  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */
  
  exports.enable(load());
  
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */
  
  function localstorage(){
    try {
      return window.localStorage;
    } catch (e) {}
  }
  

  return module.exports;
}).call({exports:{}});
_m_['src/lib/cursor.js']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  var keys = _m_['@yr/keys/index.js#1.1.2'];
  
  /**
   * Instance factory
   * @param {String} key
   * @param {DataStore} dataStore
   * @returns {DataStoreCursor}
   */
  exports.create = function create(key, dataStore) {
    return new DataStoreCursor(key, dataStore);
  };
  
  var DataStoreCursor = function () {
    /**
     * Constructor
     * @param {String} key
     * @param {DataStore} dataStore
     */
  
    function DataStoreCursor(key, dataStore) {
      babelHelpers.classCallCheck(this, DataStoreCursor);
  
      this.dataStore = dataStore;
      this.key = key;
    }
  
    /**
     * Retrieve prop value with `key`
     * @param {String} [key]
     * @returns {Object}
     */
  
  
    DataStoreCursor.prototype.get = function get(key) {
      var _this = this;
  
      var fixKey = function fixKey(key) {
        // Prefix with cursor key if not root
        return !_this.dataStore.isRootKey(key) ? keys.join(_this.key, key) : key;
      };
  
      // Handle empty key (set value at cursor root)
      if (!key) key = this.key;
      // Handle array of keys
      key = Array.isArray(key) ? key.map(fixKey) : fixKey(key);
  
      return this.dataStore.get(key);
    };
  
    /**
     * Store prop 'key' with 'value', notifying listeners of change
     * @param {String} key
     * @param {Object} value
     * @param {Object} [options]
     */
  
  
    DataStoreCursor.prototype.update = function update(key, value, options) {
      var _key;
  
      // Handle empty key (set value at cursor root)
      if (!key) key = this.key;
  
      // Convert to batch
      if ('string' == typeof key) key = (_key = {}, _key[key] = value, _key);
  
      // Fix keys (prefix with cursor key if not root)
      for (var k in key) {
        if (!this.dataStore.isRootKey(k)) {
          key[keys.join(this.key, k)] = key[k];
          delete key[k];
        }
      }
  
      // Batch update
      this.dataStore.update(key, options);
    };
  
    /**
     * Retrieve an instance reference at 'key' to a subset of data
     * @param {String} key
     * @returns {DataStoreCursor}
     */
  
  
    DataStoreCursor.prototype.createCursor = function createCursor(key) {
      return new DataStoreCursor(keys.join(this.key, key), this.dataStore);
    };
  
    /**
     * Destroy instance
     */
  
  
    DataStoreCursor.prototype.destroy = function destroy() {
      this.dataStore = null;
    };
  
    return DataStoreCursor;
  }();

  return module.exports;
}).call({exports:{}});
_m_['performance-now/lib/performance-now.js#0.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  // Generated by CoffeeScript 1.7.1
  (function() {
    var getNanoSeconds, hrtime, loadTime;
  
    if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
      module.exports = function() {
        return performance.now();
      };
    } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
      module.exports = function() {
        return (getNanoSeconds() - loadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      loadTime = getNanoSeconds();
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  
  }).call(this);
  

  return module.exports;
}).call({exports:{}});
_m_['raf/index.js#3.2.0']=(function(module,exports){
  module=this;exports=module.exports;

  var now = _m_['performance-now/lib/performance-now.js#0.2.0']
    , root = typeof window === 'undefined' ? global : window
    , vendors = ['moz', 'webkit']
    , suffix = 'AnimationFrame'
    , raf = root['request' + suffix]
    , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]
  
  for(var i = 0; !raf && i < vendors.length; i++) {
    raf = root[vendors[i] + 'Request' + suffix]
    caf = root[vendors[i] + 'Cancel' + suffix]
        || root[vendors[i] + 'CancelRequest' + suffix]
  }
  
  // Some versions of FF have rAF but not cAF
  if(!raf || !caf) {
    var last = 0
      , id = 0
      , queue = []
      , frameDuration = 1000 / 60
  
    raf = function(callback) {
      if(queue.length === 0) {
        var _now = now()
          , next = Math.max(0, frameDuration - (_now - last))
        last = next + _now
        setTimeout(function() {
          var cp = queue.slice(0)
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0
          for(var i = 0; i < cp.length; i++) {
            if(!cp[i].cancelled) {
              try{
                cp[i].callback(last)
              } catch(e) {
                setTimeout(function() { throw e }, 0)
              }
            }
          }
        }, Math.round(next))
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      })
      return id
    }
  
    caf = function(handle) {
      for(var i = 0; i < queue.length; i++) {
        if(queue[i].handle === handle) {
          queue[i].cancelled = true
        }
      }
    }
  }
  
  module.exports = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn)
  }
  module.exports.cancel = function() {
    caf.apply(root, arguments)
  }
  module.exports.polyfill = function() {
    root.requestAnimationFrame = raf
    root.cancelAnimationFrame = caf
  }
  

  return module.exports;
}).call({exports:{}});
_m_['@yr/clock/index.js#1.1.8']=(function(module,exports){
  module=this;exports=module.exports;

  'use strict';
  
  /**
   * A global timer utility for managing immediate/timeout intervals
   * https://github.com/yr/clock
   * @copyright Yr
   * @license MIT
   */
  
  var Debug = _m_['debug/browser.js#2.2.0'];
  var raf = _m_['raf/index.js#3.2.0'];
  var now = _m_['performance-now/lib/performance-now.js#0.2.0'];
  
  var INTERVAL_CUTOFF = 1000;
  var INTERVAL_MAX = 600000;
  
  var debug = Debug('yr:clock');
  var hasImmediate = 'setImmediate' in (typeof global !== 'undefined' ? global : window);
  var queue = {};
  var rafHandle = 0;
  var stHandle = 0;
  var uid = 0;
  
  // Add polyfills
  raf.polyfill();
  
  module.exports = {
    /**
     * Initialize with visibility api "features"
     * @param {Object} features
     */
  
    initialize: function initialize(features) {
      var hidden = features.hidden;
      var visibilityChange = features.visibilityChange;
  
      if (hidden) {
        document.addEventListener(visibilityChange, function (evt) {
          if (document[hidden]) {
            debug('disable while hidden');
            stop();
          } else {
            var current = now();
            var running = false;
  
            debug('enable while visible');
            for (var id in queue) {
              var item = queue[id];
  
              if (item) {
                running = true;
  
                if (debug.enabled) {
                  if (item.time <= current) {
                    debug('timeout should trigger for "%s"', id);
                  } else {
                    var date = new Date();
  
                    date.setMilliseconds(date.getMilliseconds() + item.time - current);
                    debug('timeout for "%s" expected at %s', id, date.toLocaleTimeString());
                  }
                }
              } else {
                delete queue[id];
              }
            }
            if (running) run();
          }
        }, false);
      }
    },
  
  
    /**
     * Call 'fn' on next loop turn
     * @param {Function} fn
     * @returns {Number}
     */
    immediate: function immediate(fn) {
      return hasImmediate ? setImmediate(fn) : raf(fn);
    },
  
  
    /**
     * Call 'fn' on next animation frame
     * @param {Function} fn
     * @returns {Number}
     */
    frame: function frame(fn) {
      return raf(fn);
    },
  
  
    /**
     * Call 'fn' after 'duration'
     * @param {Number} duration - ms
     * @param {Function} fn
     * @param {String} [id]
     * @returns {String|Number|Object}
     */
    timeout: function timeout(duration, fn, id) {
      if (duration <= 0) return this.immediate(fn);
  
      var time = now() + duration;
  
      id = id || 'c::' + ++uid;
      // Existing ids will be overwritten/cancelled
      queue[id] = { fn: fn, time: time };
  
      if (debug.enabled) {
        var date = new Date();
  
        date.setMilliseconds(date.getMilliseconds() + duration);
        debug('timeout scheduled for "%s" at %s', id, date.toLocaleTimeString());
      }
  
      run();
  
      return id;
    },
  
  
    /**
     * Cancel immediate/timeout with 'id'
     * @param {String|Number} id
     * @returns {String|Number}
     */
    cancel: function cancel(id) {
      switch (typeof id) {
        // Timeout
        case 'string':
          if (id in queue) {
            debug('timeout canceled for "%s"', id);
            delete queue[id];
          }
          return '';
        // Immediate raf
        case 'number':
          raf.cancel(id);
          return 0;
        // Immediate setImmediate
        case 'object':
          clearImmediate(id);
          return null;
      }
    }
  };
  
  /**
   * Process outstanding queue items
   */
  function run() {
    var current = now();
    var interval = INTERVAL_MAX;
    var running = false;
  
    // Reset
    if (rafHandle || stHandle) stop();
  
    for (var id in queue) {
      var item = queue[id];
      var duration = item.time - current;
  
      if (duration <= 0) {
        if (debug.enabled) debug('timeout triggered for "%s" at %s', id, new Date().toLocaleTimeString());
        delete queue[id];
        item.fn();
      } else {
        // Store smallest duration
        if (duration < interval) interval = duration;
        running = true;
      }
    }
  
    // Loop
    if (running) {
      // Use raf if requested interval is less than cutoff
      if (interval < INTERVAL_CUTOFF) {
        rafHandle = raf(run);
      } else {
        stHandle = setTimeout(run, interval);
      }
    }
  }
  
  /**
   * Stop running
   */
  function stop() {
    if (rafHandle) raf.cancel(rafHandle);
    if (stHandle) clearTimeout(stHandle);
    rafHandle = 0;
    stHandle = 0;
  }

  return module.exports;
}).call({exports:{}});
_m_['object-assign/index.js#4.0.1']=(function(module,exports){
  module=this;exports=module.exports;

  /* eslint-disable no-unused-vars */
  'use strict';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  
  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}
  
  	return Object(val);
  }
  
  module.exports = Object.assign || function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;
  
  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);
  
  		for (var key in from) {
  			if (hasOwnProperty.call(from, key)) {
  				to[key] = from[key];
  			}
  		}
  
  		if (Object.getOwnPropertySymbols) {
  			symbols = Object.getOwnPropertySymbols(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}
  
  	return to;
  };
  

  return module.exports;
}).call({exports:{}});
_m_['superagent-retry/lib/retries.js#0.5.1']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * Common retry conditions
   */
  
  module.exports = [
    econnreset,
    etimedout,
    eaddrinfo,
    esockettimedout,
    gateway,
    timeout
  ];
  
  
  /**
   * Connection reset detection
   */
  
  function econnreset (err, res) {
    return err && err.code === 'ECONNRESET';
  }
  
  
  /**
   * Timeout detection
   */
  
  function etimedout (err, res) {
    return err && err.code === 'ETIMEDOUT';
  }
  
  
  /**
   * Can't get address info
   */
  
  function eaddrinfo (err, res) {
    return err && err.code === 'EADDRINFO';
  }
  
  
  /**
   * Socket timeout detection
   */
  
  function esockettimedout (err, res) {
    return err && err.code === 'ESOCKETTIMEDOUT';
  }
  
  
  /**
   * Bad gateway error detection
   */
  
  function gateway (err, res) {
    return res && [502,503,504].indexOf(res.status) !== -1;
  }
  
  
  /**
   * Superagent timeout errors
   */
  
  function timeout (err, res) {
    return err && /^timeout of \d+ms exceeded$/.test(err.message);
  }

  return module.exports;
}).call({exports:{}});
_m_['superagent/lib/request.js#1.8.3']=(function(module,exports){
  module=this;exports=module.exports;

  // The node and browser modules expose versions of this with the
  // appropriate constructor function bound as first argument
  /**
   * Issue a request:
   *
   * Examples:
   *
   *    request('GET', '/users').end(callback)
   *    request('/users').end(callback)
   *    request('/users', callback)
   *
   * @param {String} method
   * @param {String|Function} url or callback
   * @return {Request}
   * @api public
   */
  
  function request(RequestConstructor, method, url) {
    // callback
    if ('function' == typeof url) {
      return new RequestConstructor('GET', method).end(url);
    }
  
    // url first
    if (2 == arguments.length) {
      return new RequestConstructor('GET', method);
    }
  
    return new RequestConstructor(method, url);
  }
  
  module.exports = request;
  

  return module.exports;
}).call({exports:{}});
_m_['superagent/lib/is-object.js#1.8.3']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * Check if `obj` is an object.
   *
   * @param {Object} obj
   * @return {Boolean}
   * @api private
   */
  
  function isObject(obj) {
    return null != obj && 'object' == typeof obj;
  }
  
  module.exports = isObject;
  

  return module.exports;
}).call({exports:{}});
_m_['superagent/lib/request-base.js#1.8.3']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * Module of mixed-in functions shared between node and client code
   */
  var isObject = _m_['superagent/lib/is-object.js#1.8.3'];
  
  /**
   * Clear previous timeout.
   *
   * @return {Request} for chaining
   * @api public
   */
  
  exports.clearTimeout = function _clearTimeout(){
    this._timeout = 0;
    clearTimeout(this._timer);
    return this;
  };
  
  /**
   * Force given parser
   *
   * Sets the body parser no matter type.
   *
   * @param {Function}
   * @api public
   */
  
  exports.parse = function parse(fn){
    this._parser = fn;
    return this;
  };
  
  /**
   * Set timeout to `ms`.
   *
   * @param {Number} ms
   * @return {Request} for chaining
   * @api public
   */
  
  exports.timeout = function timeout(ms){
    this._timeout = ms;
    return this;
  };
  
  /**
   * Faux promise support
   *
   * @param {Function} fulfill
   * @param {Function} reject
   * @return {Request}
   */
  
  exports.then = function then(fulfill, reject) {
    return this.end(function(err, res) {
      err ? reject(err) : fulfill(res);
    });
  }
  
  /**
   * Allow for extension
   */
  
  exports.use = function use(fn) {
    fn(this);
    return this;
  }
  
  
  /**
   * Get request header `field`.
   * Case-insensitive.
   *
   * @param {String} field
   * @return {String}
   * @api public
   */
  
  exports.get = function(field){
    return this._header[field.toLowerCase()];
  };
  
  /**
   * Get case-insensitive header `field` value.
   * This is a deprecated internal API. Use `.get(field)` instead.
   *
   * (getHeader is no longer used internally by the superagent code base)
   *
   * @param {String} field
   * @return {String}
   * @api private
   * @deprecated
   */
  
  exports.getHeader = exports.get;
  
  /**
   * Set header `field` to `val`, or multiple fields with one object.
   * Case-insensitive.
   *
   * Examples:
   *
   *      req.get('/')
   *        .set('Accept', 'application/json')
   *        .set('X-API-Key', 'foobar')
   *        .end(callback);
   *
   *      req.get('/')
   *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
   *        .end(callback);
   *
   * @param {String|Object} field
   * @param {String} val
   * @return {Request} for chaining
   * @api public
   */
  
  exports.set = function(field, val){
    if (isObject(field)) {
      for (var key in field) {
        this.set(key, field[key]);
      }
      return this;
    }
    this._header[field.toLowerCase()] = val;
    this.header[field] = val;
    return this;
  };
  
  /**
   * Remove header `field`.
   * Case-insensitive.
   *
   * Example:
   *
   *      req.get('/')
   *        .unset('User-Agent')
   *        .end(callback);
   *
   * @param {String} field
   */
  exports.unset = function(field){
    delete this._header[field.toLowerCase()];
    delete this.header[field];
    return this;
  };
  
  /**
   * Write the field `name` and `val` for "multipart/form-data"
   * request bodies.
   *
   * ``` js
   * request.post('/upload')
   *   .field('foo', 'bar')
   *   .end(callback);
   * ```
   *
   * @param {String} name
   * @param {String|Blob|File|Buffer|fs.ReadStream} val
   * @return {Request} for chaining
   * @api public
   */
  exports.field = function(name, val) {
    this._getFormData().append(name, val);
    return this;
  };
  

  return module.exports;
}).call({exports:{}});
_m_['reduce-component/index.js#1.0.1']=(function(module,exports){
  module=this;exports=module.exports;

  
  /**
   * Reduce `arr` with `fn`.
   *
   * @param {Array} arr
   * @param {Function} fn
   * @param {Mixed} initial
   *
   * TODO: combatible error handling?
   */
  
  module.exports = function(arr, fn, initial){  
    var idx = 0;
    var len = arr.length;
    var curr = arguments.length == 3
      ? initial
      : arr[idx++];
  
    while (idx < len) {
      curr = fn.call(null, curr, arr[idx], ++idx, arr);
    }
    
    return curr;
  };

  return module.exports;
}).call({exports:{}});
_m_['component-emitter/index.js#1.2.1']=(function(module,exports){
  module=this;exports=module.exports;

    
  /**  
   * Expose `Emitter`.  
   */  
    
  if (typeof module !== 'undefined') {  
    module.exports = Emitter;  
  }  
    
  /**  
   * Initialize a new `Emitter`.  
   *  
   * @api public  
   */  
    
  function Emitter(obj) {  
    if (obj) return mixin(obj);  
  };  
    
  /**  
   * Mixin the emitter properties.  
   *  
   * @param {Object} obj  
   * @return {Object}  
   * @api private  
   */  
    
  function mixin(obj) {  
    for (var key in Emitter.prototype) {  
      obj[key] = Emitter.prototype[key];  
    }  
    return obj;  
  }  
    
  /**  
   * Listen on the given `event` with `fn`.  
   *  
   * @param {String} event  
   * @param {Function} fn  
   * @return {Emitter}  
   * @api public  
   */  
    
  Emitter.prototype.on =  
  Emitter.prototype.addEventListener = function(event, fn){  
    this._callbacks = this._callbacks || {};  
    (this._callbacks['$' + event] = this._callbacks['$' + event] || [])  
      .push(fn);  
    return this;  
  };  
    
  /**  
   * Adds an `event` listener that will be invoked a single  
   * time then automatically removed.  
   *  
   * @param {String} event  
   * @param {Function} fn  
   * @return {Emitter}  
   * @api public  
   */  
    
  Emitter.prototype.once = function(event, fn){  
    function on() {  
      this.off(event, on);  
      fn.apply(this, arguments);  
    }  
    
    on.fn = fn;  
    this.on(event, on);  
    return this;  
  };  
    
  /**  
   * Remove the given callback for `event` or all  
   * registered callbacks.  
   *  
   * @param {String} event  
   * @param {Function} fn  
   * @return {Emitter}  
   * @api public  
   */  
    
  Emitter.prototype.off =  
  Emitter.prototype.removeListener =  
  Emitter.prototype.removeAllListeners =  
  Emitter.prototype.removeEventListener = function(event, fn){  
    this._callbacks = this._callbacks || {};  
    
    // all  
    if (0 == arguments.length) {  
      this._callbacks = {};  
      return this;  
    }  
    
    // specific event  
    var callbacks = this._callbacks['$' + event];  
    if (!callbacks) return this;  
    
    // remove all handlers  
    if (1 == arguments.length) {  
      delete this._callbacks['$' + event];  
      return this;  
    }  
    
    // remove specific handler  
    var cb;  
    for (var i = 0; i < callbacks.length; i++) {  
      cb = callbacks[i];  
      if (cb === fn || cb.fn === fn) {  
        callbacks.splice(i, 1);  
        break;  
      }  
    }  
    return this;  
  };  
    
  /**  
   * Emit `event` with the given args.  
   *  
   * @param {String} event  
   * @param {Mixed} ...  
   * @return {Emitter}  
   */  
    
  Emitter.prototype.emit = function(event){  
    this._callbacks = this._callbacks || {};  
    var args = [].slice.call(arguments, 1)  
      , callbacks = this._callbacks['$' + event];  
    
    if (callbacks) {  
      callbacks = callbacks.slice(0);  
      for (var i = 0, len = callbacks.length; i < len; ++i) {  
        callbacks[i].apply(this, args);  
      }  
    }  
    
    return this;  
  };  
    
  /**  
   * Return array of callbacks for `event`.  
   *  
   * @param {String} event  
   * @return {Array}  
   * @api public  
   */  
    
  Emitter.prototype.listeners = function(event){  
    this._callbacks = this._callbacks || {};  
    return this._callbacks['$' + event] || [];  
  };  
    
  /**  
   * Check if this emitter has `event` handlers.  
   *  
   * @param {String} event  
   * @return {Boolean}  
   * @api public  
   */  
    
  Emitter.prototype.hasListeners = function(event){  
    return !! this.listeners(event).length;  
  };  
  

  return module.exports;
}).call({exports:{}});
_m_['superagent/lib/client.js#1.8.3']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * Module dependencies.
   */
  
  var Emitter = _m_['component-emitter/index.js#1.2.1'];
  var reduce = _m_['reduce-component/index.js#1.0.1'];
  var requestBase = _m_['superagent/lib/request-base.js#1.8.3'];
  var isObject = _m_['superagent/lib/is-object.js#1.8.3'];
  
  /**
   * Root reference for iframes.
   */
  
  var root;
  if (typeof window !== 'undefined') { // Browser window
    root = window;
  } else if (typeof self !== 'undefined') { // Web Worker
    root = self;
  } else { // Other environments
    root = this;
  }
  
  /**
   * Noop.
   */
  
  function noop(){};
  
  /**
   * Check if `obj` is a host object,
   * we don't want to serialize these :)
   *
   * TODO: future proof, move to compoent land
   *
   * @param {Object} obj
   * @return {Boolean}
   * @api private
   */
  
  function isHost(obj) {
    var str = {}.toString.call(obj);
  
    switch (str) {
      case '[object File]':
      case '[object Blob]':
      case '[object FormData]':
        return true;
      default:
        return false;
    }
  }
  
  /**
   * Expose `request`.
   */
  
  var request = module.exports = _m_['superagent/lib/request.js#1.8.3'].bind(null, Request);
  
  /**
   * Determine XHR.
   */
  
  request.getXHR = function () {
    if (root.XMLHttpRequest
        && (!root.location || 'file:' != root.location.protocol
            || !root.ActiveXObject)) {
      return new XMLHttpRequest;
    } else {
      try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
      try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
      try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
      try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
    }
    return false;
  };
  
  /**
   * Removes leading and trailing whitespace, added to support IE.
   *
   * @param {String} s
   * @return {String}
   * @api private
   */
  
  var trim = ''.trim
    ? function(s) { return s.trim(); }
    : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };
  
  /**
   * Serialize the given `obj`.
   *
   * @param {Object} obj
   * @return {String}
   * @api private
   */
  
  function serialize(obj) {
    if (!isObject(obj)) return obj;
    var pairs = [];
    for (var key in obj) {
      if (null != obj[key]) {
        pushEncodedKeyValuePair(pairs, key, obj[key]);
          }
        }
    return pairs.join('&');
  }
  
  /**
   * Helps 'serialize' with serializing arrays.
   * Mutates the pairs array.
   *
   * @param {Array} pairs
   * @param {String} key
   * @param {Mixed} val
   */
  
  function pushEncodedKeyValuePair(pairs, key, val) {
    if (Array.isArray(val)) {
      return val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    }
    pairs.push(encodeURIComponent(key)
      + '=' + encodeURIComponent(val));
  }
  
  /**
   * Expose serialization method.
   */
  
   request.serializeObject = serialize;
  
   /**
    * Parse the given x-www-form-urlencoded `str`.
    *
    * @param {String} str
    * @return {Object}
    * @api private
    */
  
  function parseString(str) {
    var obj = {};
    var pairs = str.split('&');
    var parts;
    var pair;
  
    for (var i = 0, len = pairs.length; i < len; ++i) {
      pair = pairs[i];
      parts = pair.split('=');
      obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
    }
  
    return obj;
  }
  
  /**
   * Expose parser.
   */
  
  request.parseString = parseString;
  
  /**
   * Default MIME type map.
   *
   *     superagent.types.xml = 'application/xml';
   *
   */
  
  request.types = {
    html: 'text/html',
    json: 'application/json',
    xml: 'application/xml',
    urlencoded: 'application/x-www-form-urlencoded',
    'form': 'application/x-www-form-urlencoded',
    'form-data': 'application/x-www-form-urlencoded'
  };
  
  /**
   * Default serialization map.
   *
   *     superagent.serialize['application/xml'] = function(obj){
   *       return 'generated xml here';
   *     };
   *
   */
  
   request.serialize = {
     'application/x-www-form-urlencoded': serialize,
     'application/json': JSON.stringify
   };
  
   /**
    * Default parsers.
    *
    *     superagent.parse['application/xml'] = function(str){
    *       return { object parsed from str };
    *     };
    *
    */
  
  request.parse = {
    'application/x-www-form-urlencoded': parseString,
    'application/json': JSON.parse
  };
  
  /**
   * Parse the given header `str` into
   * an object containing the mapped fields.
   *
   * @param {String} str
   * @return {Object}
   * @api private
   */
  
  function parseHeader(str) {
    var lines = str.split(/\r?\n/);
    var fields = {};
    var index;
    var line;
    var field;
    var val;
  
    lines.pop(); // trailing CRLF
  
    for (var i = 0, len = lines.length; i < len; ++i) {
      line = lines[i];
      index = line.indexOf(':');
      field = line.slice(0, index).toLowerCase();
      val = trim(line.slice(index + 1));
      fields[field] = val;
    }
  
    return fields;
  }
  
  /**
   * Check if `mime` is json or has +json structured syntax suffix.
   *
   * @param {String} mime
   * @return {Boolean}
   * @api private
   */
  
  function isJSON(mime) {
    return /[\/+]json\b/.test(mime);
  }
  
  /**
   * Return the mime type for the given `str`.
   *
   * @param {String} str
   * @return {String}
   * @api private
   */
  
  function type(str){
    return str.split(/ *; */).shift();
  };
  
  /**
   * Return header field parameters.
   *
   * @param {String} str
   * @return {Object}
   * @api private
   */
  
  function params(str){
    return reduce(str.split(/ *; */), function(obj, str){
      var parts = str.split(/ *= */)
        , key = parts.shift()
        , val = parts.shift();
  
      if (key && val) obj[key] = val;
      return obj;
    }, {});
  };
  
  /**
   * Initialize a new `Response` with the given `xhr`.
   *
   *  - set flags (.ok, .error, etc)
   *  - parse header
   *
   * Examples:
   *
   *  Aliasing `superagent` as `request` is nice:
   *
   *      request = superagent;
   *
   *  We can use the promise-like API, or pass callbacks:
   *
   *      request.get('/').end(function(res){});
   *      request.get('/', function(res){});
   *
   *  Sending data can be chained:
   *
   *      request
   *        .post('/user')
   *        .send({ name: 'tj' })
   *        .end(function(res){});
   *
   *  Or passed to `.send()`:
   *
   *      request
   *        .post('/user')
   *        .send({ name: 'tj' }, function(res){});
   *
   *  Or passed to `.post()`:
   *
   *      request
   *        .post('/user', { name: 'tj' })
   *        .end(function(res){});
   *
   * Or further reduced to a single call for simple cases:
   *
   *      request
   *        .post('/user', { name: 'tj' }, function(res){});
   *
   * @param {XMLHTTPRequest} xhr
   * @param {Object} options
   * @api private
   */
  
  function Response(req, options) {
    options = options || {};
    this.req = req;
    this.xhr = this.req.xhr;
    // responseText is accessible only if responseType is '' or 'text' and on older browsers
    this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
       ? this.xhr.responseText
       : null;
    this.statusText = this.req.xhr.statusText;
    this.setStatusProperties(this.xhr.status);
    this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
    // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
    // getResponseHeader still works. so we get content-type even if getting
    // other headers fails.
    this.header['content-type'] = this.xhr.getResponseHeader('content-type');
    this.setHeaderProperties(this.header);
    this.body = this.req.method != 'HEAD'
      ? this.parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
  
  /**
   * Get case-insensitive `field` value.
   *
   * @param {String} field
   * @return {String}
   * @api public
   */
  
  Response.prototype.get = function(field){
    return this.header[field.toLowerCase()];
  };
  
  /**
   * Set header related properties:
   *
   *   - `.type` the content type without params
   *
   * A response of "Content-Type: text/plain; charset=utf-8"
   * will provide you with a `.type` of "text/plain".
   *
   * @param {Object} header
   * @api private
   */
  
  Response.prototype.setHeaderProperties = function(header){
    // content-type
    var ct = this.header['content-type'] || '';
    this.type = type(ct);
  
    // params
    var obj = params(ct);
    for (var key in obj) this[key] = obj[key];
  };
  
  /**
   * Parse the given body `str`.
   *
   * Used for auto-parsing of bodies. Parsers
   * are defined on the `superagent.parse` object.
   *
   * @param {String} str
   * @return {Mixed}
   * @api private
   */
  
  Response.prototype.parseBody = function(str){
    var parse = request.parse[this.type];
    if (!parse && isJSON(this.type)) {
      parse = request.parse['application/json'];
    }
    return parse && str && (str.length || str instanceof Object)
      ? parse(str)
      : null;
  };
  
  /**
   * Set flags such as `.ok` based on `status`.
   *
   * For example a 2xx response will give you a `.ok` of __true__
   * whereas 5xx will be __false__ and `.error` will be __true__. The
   * `.clientError` and `.serverError` are also available to be more
   * specific, and `.statusType` is the class of error ranging from 1..5
   * sometimes useful for mapping respond colors etc.
   *
   * "sugar" properties are also defined for common cases. Currently providing:
   *
   *   - .noContent
   *   - .badRequest
   *   - .unauthorized
   *   - .notAcceptable
   *   - .notFound
   *
   * @param {Number} status
   * @api private
   */
  
  Response.prototype.setStatusProperties = function(status){
    // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
    if (status === 1223) {
      status = 204;
    }
  
    var type = status / 100 | 0;
  
    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;
  
    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
      ? this.toError()
      : false;
  
    // sugar
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.notFound = 404 == status;
    this.forbidden = 403 == status;
  };
  
  /**
   * Return an `Error` representative of this response.
   *
   * @return {Error}
   * @api public
   */
  
  Response.prototype.toError = function(){
    var req = this.req;
    var method = req.method;
    var url = req.url;
  
    var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
    var err = new Error(msg);
    err.status = this.status;
    err.method = method;
    err.url = url;
  
    return err;
  };
  
  /**
   * Expose `Response`.
   */
  
  request.Response = Response;
  
  /**
   * Initialize a new `Request` with the given `method` and `url`.
   *
   * @param {String} method
   * @param {String} url
   * @api public
   */
  
  function Request(method, url) {
    var self = this;
    this._query = this._query || [];
    this.method = method;
    this.url = url;
    this.header = {}; // preserves header name case
    this._header = {}; // coerces header names to lowercase
    this.on('end', function(){
      var err = null;
      var res = null;
  
      try {
        res = new Response(self);
      } catch(e) {
        err = new Error('Parser is unable to parse the response');
        err.parse = true;
        err.original = e;
        // issue #675: return the raw response if the response parsing fails
        err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
        // issue #876: return the http status code if the response parsing fails
        err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
        return self.callback(err);
      }
  
      self.emit('response', res);
  
      if (err) {
        return self.callback(err, res);
      }
  
      if (res.status >= 200 && res.status < 300) {
        return self.callback(err, res);
      }
  
      var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
  
      self.callback(new_err, res);
    });
  }
  
  /**
   * Mixin `Emitter` and `requestBase`.
   */
  
  Emitter(Request.prototype);
  for (var key in requestBase) {
    Request.prototype[key] = requestBase[key];
  }
  
  /**
   * Abort the request, and clear potential timeout.
   *
   * @return {Request}
   * @api public
   */
  
  Request.prototype.abort = function(){
    if (this.aborted) return;
    this.aborted = true;
    this.xhr.abort();
    this.clearTimeout();
    this.emit('abort');
    return this;
  };
  
  /**
   * Set Content-Type to `type`, mapping values from `request.types`.
   *
   * Examples:
   *
   *      superagent.types.xml = 'application/xml';
   *
   *      request.post('/')
   *        .type('xml')
   *        .send(xmlstring)
   *        .end(callback);
   *
   *      request.post('/')
   *        .type('application/xml')
   *        .send(xmlstring)
   *        .end(callback);
   *
   * @param {String} type
   * @return {Request} for chaining
   * @api public
   */
  
  Request.prototype.type = function(type){
    this.set('Content-Type', request.types[type] || type);
    return this;
  };
  
  /**
   * Set responseType to `val`. Presently valid responseTypes are 'blob' and 
   * 'arraybuffer'.
   *
   * Examples:
   *
   *      req.get('/')
   *        .responseType('blob')
   *        .end(callback);
   *
   * @param {String} val
   * @return {Request} for chaining
   * @api public
   */
  
  Request.prototype.responseType = function(val){
    this._responseType = val;
    return this;
  };
  
  /**
   * Set Accept to `type`, mapping values from `request.types`.
   *
   * Examples:
   *
   *      superagent.types.json = 'application/json';
   *
   *      request.get('/agent')
   *        .accept('json')
   *        .end(callback);
   *
   *      request.get('/agent')
   *        .accept('application/json')
   *        .end(callback);
   *
   * @param {String} accept
   * @return {Request} for chaining
   * @api public
   */
  
  Request.prototype.accept = function(type){
    this.set('Accept', request.types[type] || type);
    return this;
  };
  
  /**
   * Set Authorization field value with `user` and `pass`.
   *
   * @param {String} user
   * @param {String} pass
   * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
   * @return {Request} for chaining
   * @api public
   */
  
  Request.prototype.auth = function(user, pass, options){
    if (!options) {
      options = {
        type: 'basic'
      }
    }
  
    switch (options.type) {
      case 'basic':
        var str = btoa(user + ':' + pass);
        this.set('Authorization', 'Basic ' + str);
      break;
  
      case 'auto':
        this.username = user;
        this.password = pass;
      break;
    }
    return this;
  };
  
  /**
  * Add query-string `val`.
  *
  * Examples:
  *
  *   request.get('/shoes')
  *     .query('size=10')
  *     .query({ color: 'blue' })
  *
  * @param {Object|String} val
  * @return {Request} for chaining
  * @api public
  */
  
  Request.prototype.query = function(val){
    if ('string' != typeof val) val = serialize(val);
    if (val) this._query.push(val);
    return this;
  };
  
  /**
   * Queue the given `file` as an attachment to the specified `field`,
   * with optional `filename`.
   *
   * ``` js
   * request.post('/upload')
   *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
   *   .end(callback);
   * ```
   *
   * @param {String} field
   * @param {Blob|File} file
   * @param {String} filename
   * @return {Request} for chaining
   * @api public
   */
  
  Request.prototype.attach = function(field, file, filename){
    this._getFormData().append(field, file, filename || file.name);
    return this;
  };
  
  Request.prototype._getFormData = function(){
    if (!this._formData) {
      this._formData = new root.FormData();
    }
    return this._formData;
  };
  
  /**
   * Send `data` as the request body, defaulting the `.type()` to "json" when
   * an object is given.
   *
   * Examples:
   *
   *       // manual json
   *       request.post('/user')
   *         .type('json')
   *         .send('{"name":"tj"}')
   *         .end(callback)
   *
   *       // auto json
   *       request.post('/user')
   *         .send({ name: 'tj' })
   *         .end(callback)
   *
   *       // manual x-www-form-urlencoded
   *       request.post('/user')
   *         .type('form')
   *         .send('name=tj')
   *         .end(callback)
   *
   *       // auto x-www-form-urlencoded
   *       request.post('/user')
   *         .type('form')
   *         .send({ name: 'tj' })
   *         .end(callback)
   *
   *       // defaults to x-www-form-urlencoded
    *      request.post('/user')
    *        .send('name=tobi')
    *        .send('species=ferret')
    *        .end(callback)
   *
   * @param {String|Object} data
   * @return {Request} for chaining
   * @api public
   */
  
  Request.prototype.send = function(data){
    var obj = isObject(data);
    var type = this._header['content-type'];
  
    // merge
    if (obj && isObject(this._data)) {
      for (var key in data) {
        this._data[key] = data[key];
      }
    } else if ('string' == typeof data) {
      if (!type) this.type('form');
      type = this._header['content-type'];
      if ('application/x-www-form-urlencoded' == type) {
        this._data = this._data
          ? this._data + '&' + data
          : data;
      } else {
        this._data = (this._data || '') + data;
      }
    } else {
      this._data = data;
    }
  
    if (!obj || isHost(data)) return this;
    if (!type) this.type('json');
    return this;
  };
  
  /**
   * @deprecated
   */
  Response.prototype.parse = function serialize(fn){
    if (root.console) {
      console.warn("Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0");
    }
    this.serialize(fn);
    return this;
  };
  
  Response.prototype.serialize = function serialize(fn){
    this._parser = fn;
    return this;
  };
  
  /**
   * Invoke the callback with `err` and `res`
   * and handle arity check.
   *
   * @param {Error} err
   * @param {Response} res
   * @api private
   */
  
  Request.prototype.callback = function(err, res){
    var fn = this._callback;
    this.clearTimeout();
    fn(err, res);
  };
  
  /**
   * Invoke callback with x-domain error.
   *
   * @api private
   */
  
  Request.prototype.crossDomainError = function(){
    var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
    err.crossDomain = true;
  
    err.status = this.status;
    err.method = this.method;
    err.url = this.url;
  
    this.callback(err);
  };
  
  /**
   * Invoke callback with timeout error.
   *
   * @api private
   */
  
  Request.prototype.timeoutError = function(){
    var timeout = this._timeout;
    var err = new Error('timeout of ' + timeout + 'ms exceeded');
    err.timeout = timeout;
    this.callback(err);
  };
  
  /**
   * Enable transmission of cookies with x-domain requests.
   *
   * Note that for this to work the origin must not be
   * using "Access-Control-Allow-Origin" with a wildcard,
   * and also must set "Access-Control-Allow-Credentials"
   * to "true".
   *
   * @api public
   */
  
  Request.prototype.withCredentials = function(){
    this._withCredentials = true;
    return this;
  };
  
  /**
   * Initiate request, invoking callback `fn(res)`
   * with an instanceof `Response`.
   *
   * @param {Function} fn
   * @return {Request} for chaining
   * @api public
   */
  
  Request.prototype.end = function(fn){
    var self = this;
    var xhr = this.xhr = request.getXHR();
    var query = this._query.join('&');
    var timeout = this._timeout;
    var data = this._formData || this._data;
  
    // store callback
    this._callback = fn || noop;
  
    // state change
    xhr.onreadystatechange = function(){
      if (4 != xhr.readyState) return;
  
      // In IE9, reads to any property (e.g. status) off of an aborted XHR will
      // result in the error "Could not complete the operation due to error c00c023f"
      var status;
      try { status = xhr.status } catch(e) { status = 0; }
  
      if (0 == status) {
        if (self.timedout) return self.timeoutError();
        if (self.aborted) return;
        return self.crossDomainError();
      }
      self.emit('end');
    };
  
    // progress
    var handleProgress = function(e){
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      e.direction = 'download';
      self.emit('progress', e);
    };
    if (this.hasListeners('progress')) {
      xhr.onprogress = handleProgress;
    }
    try {
      if (xhr.upload && this.hasListeners('progress')) {
        xhr.upload.onprogress = handleProgress;
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  
    // timeout
    if (timeout && !this._timer) {
      this._timer = setTimeout(function(){
        self.timedout = true;
        self.abort();
      }, timeout);
    }
  
    // querystring
    if (query) {
      query = request.serializeObject(query);
      this.url += ~this.url.indexOf('?')
        ? '&' + query
        : '?' + query;
    }
  
    // initiate request
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  
    // CORS
    if (this._withCredentials) xhr.withCredentials = true;
  
    // body
    if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
      // serialize stuff
      var contentType = this._header['content-type'];
      var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
      if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
      if (serialize) data = serialize(data);
    }
  
    // set header fields
    for (var field in this.header) {
      if (null == this.header[field]) continue;
      xhr.setRequestHeader(field, this.header[field]);
    }
  
    if (this._responseType) {
      xhr.responseType = this._responseType;
    }
  
    // send stuff
    this.emit('request', this);
  
    // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
    // We need null here if data is undefined
    xhr.send(typeof data !== 'undefined' ? data : null);
    return this;
  };
  
  
  /**
   * Expose `Request`.
   */
  
  request.Request = Request;
  
  /**
   * GET `url` with optional callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed|Function} data or fn
   * @param {Function} fn
   * @return {Request}
   * @api public
   */
  
  request.get = function(url, data, fn){
    var req = request('GET', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.query(data);
    if (fn) req.end(fn);
    return req;
  };
  
  /**
   * HEAD `url` with optional callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed|Function} data or fn
   * @param {Function} fn
   * @return {Request}
   * @api public
   */
  
  request.head = function(url, data, fn){
    var req = request('HEAD', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };
  
  /**
   * DELETE `url` with optional callback `fn(res)`.
   *
   * @param {String} url
   * @param {Function} fn
   * @return {Request}
   * @api public
   */
  
  function del(url, fn){
    var req = request('DELETE', url);
    if (fn) req.end(fn);
    return req;
  };
  
  request['del'] = del;
  request['delete'] = del;
  
  /**
   * PATCH `url` with optional `data` and callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed} data
   * @param {Function} fn
   * @return {Request}
   * @api public
   */
  
  request.patch = function(url, data, fn){
    var req = request('PATCH', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };
  
  /**
   * POST `url` with optional `data` and callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed} data
   * @param {Function} fn
   * @return {Request}
   * @api public
   */
  
  request.post = function(url, data, fn){
    var req = request('POST', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };
  
  /**
   * PUT `url` with optional `data` and callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed|Function} data or fn
   * @param {Function} fn
   * @return {Request}
   * @api public
   */
  
  request.put = function(url, data, fn){
    var req = request('PUT', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };
  

  return module.exports;
}).call({exports:{}});
_m_['@yr/agent/index.js#3.3.2']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * Extension to superagent to support retrying and collapsing request queues
   * https://github.com/yr/agent
   * @copyright Yr
   * @license MIT
   */
  
  'use strict';
  
  var Debug = _m_['debug/browser.js#2.2.0'];
  var Emitter = _m_['eventemitter3/index.js#1.2.0'];
  var assign = _m_['object-assign/index.js#4.0.1'];
  var superagent = _m_['superagent/lib/client.js#1.8.3'];
  var retryList = _m_['superagent-retry/lib/retries.js#0.5.1'];
  
  var DEFAULT_RETRY = 0;
  
  var debug = Debug('yr:agent');
  var Request = superagent.Request;
  var oldEnd = Request.prototype.end;
  var cache = {};
  
  // Inherit
  assign(exports, Emitter.prototype);
  
  /**
   * GET request for 'url'
   * @param {String} url
   * @param {Object} [options]
   * @returns {Request}
   */
  exports.get = function (url, options) {
    options = options || {};
  
    var key = options.ignoreQuery ? 'get:' + url.split('?')[0] : 'get:' + url;
    var req = cache[key];
  
    if (req) {
      // Return cached
      if (!options.abort) return req;
      // Abort/clean up existing
      req.abort();
    }
  
    // Grab patched instance
    req = superagent.get(url);
    req.__agent__ = {
      abortTimeout: 0,
      callbacks: [],
      key: key,
      retries: DEFAULT_RETRY,
      retrying: false,
      start: 0
    };
  
    // Cache
    cache[key] = req;
  
    req.on('abort', onAbort);
  
    return req;
  };
  
  /**
   * POST request for 'url'
   * @param {String} url
   * @param {Object} [options]
   * @returns {Request}
   */
  exports.post = function (url, options) {
    options = options || {};
  
    var key = 'post:' + url;
    // No caching
    var req = superagent.post(url);
  
    req.__agent__ = {
      abortTimeout: 0,
      callbacks: [],
      key: key,
      retries: DEFAULT_RETRY,
      retrying: false,
      start: 0
    };
  
    req.on('abort', onAbort);
  
    return req;
  };
  
  /**
   * Set number of retry attempts
   * @param {Number} count
   * @returns {Request}
   */
  Request.prototype.retry = function (count) {
    if (this.__agent__) {
      this.__agent__.retries = count;
    }
  
    return this;
  };
  
  /**
   * Initiate request, invoking callback 'fn' on complete.
   * Overrides Superagent Request.end()
   * @param {Function} fn(err, res)
   * @returns {Request}
   */
  Request.prototype.end = function (fn) {
    // Enable default use without 'agent.get'
    if (!this.__agent__) return oldEnd.call(this, fn);
  
    // Already have response
    if (this.res) return fn(null, this.res);
  
    // Store callback
    this.__agent__.callbacks.push(fn);
  
    // Exit if already running
    // Use internal superagent prop to check if end() already called
    if (this._callback) return this;
  
    // Store start time
    this.__agent__.start = Date.now();
  
    return end(this);
  };
  
  /**
   * Trigger request for 'req'
   * @param {Request} req
   * @returns {Request}
   */
  function end(req) {
    oldEnd.call(req, function (err, res) {
      req.__agent__.retrying = false;
      // Handle error
      if (err || res.error) {
        // Retry
        if (req.__agent__.retries-- && shouldRetry(err, res)) {
          req.__agent__.retrying = true;
          // Cleanup
          resetRequest(req, err.timeout);
          return end(req);
        }
  
        var status = void 0,
            msg = void 0;
  
        // Error or response 4xx/5xx
        if (res && res.error) {
          status = res.status;
          msg = res.error.message;
        } else if (err) {
          // Handle timeout
          if (err.timeout) {
            err.statusCode = 408;
            err.message = 'request timed out';
          }
          status = err.statusCode || 500;
          msg = err.message;
        }
  
        err = new Error(msg);
        err.status = status;
  
        // Notify
        exports.emit('error', err);
      }
  
      done(req, err, res);
    });
  
    return req;
  }
  
  /**
   * Complete request for 'req', clean up and notify listeners
   * @param {Request} req
   * @param {Error} [err]
   * @param {Response} res
   */
  function done(req, err, res) {
    if (req.__agent__) {
      var duration = Date.now() - req.__agent__.start;
      // Guard against recycling of already destroyed instance
      var callbacks = req.__agent__.callbacks ? req.__agent__.callbacks.slice() : [];
  
      // Clean up
      delete cache[req.__agent__.key];
      clearTimeout(req.__agent__.abortTimeout);
      req.__agent__.callbacks = [];
      req.__agent__ = {};
      req.removeListener('abort', onAbort);
  
      if (res) res.duration = duration;
  
      debug('request to %s completed in %dms', req.url, duration);
  
      // Notify
      callbacks.forEach(function (fn) {
        fn(err, res);
      });
    }
  
    // Only if response fulfilled
    if (res) exports.emit('end', res);
  }
  
  /**
   * Handle abort
   */
  function onAbort() {
    var _this = this;
  
    clearTimeout(this.__agent__.abortTimeout);
    // Wait to determine if timeout or manual abort
    // (superagent triggers abort() before resolving timeout)
    this.__agent__.abortTimeout = setTimeout(function () {
      if (_this.__agent__.key && !_this.__agent__.retrying) {
        var err = Error('request aborted');
  
        err.status = err.statusCode = 499;
        // Normalize behaviour between node & client
        _this._aborted = _this.aborted = true;
        done(_this, err);
      }
    }, 0);
  }
  
  /**
   * Reset 'req'
   * @param {Object} req
   * @param {Number} timeout
   */
  function resetRequest(req, timeout) {
    // Server only
    if (req.req) {
      var headers = req.req._headers;
  
      req.req.abort();
      delete req.req;
  
      req.set(headers);
    }
  
    req.clearTimeout();
    clearTimeout(req.__agent__.abortTimeout);
    req.__agent__.abortTimeout = 0;
    req.called = false;
  
    req._timeout = timeout || 0;
    delete req._timer;
  }
  
  /*
   * Check if request should retry based on 'err' and 'res'
   * @param {Object} err
   * @param {Object} res
   * @returns {Boolean}
   */
  function shouldRetry(err, res) {
    return retryList.some(function (check) {
      return check(err, res);
    });
  }

  return module.exports;
}).call({exports:{}});
_m_['src/index.js']=(function(module,exports){
  module=this;exports=module.exports;

  /**
   * A clever data object
   * https://github.com/yr/data-store
   * @copyright Yr
   * @license MIT
   */
  
  'use strict';
  
  var agent = _m_['@yr/agent/index.js#3.3.2'];
  var assign = _m_['object-assign/index.js#4.0.1'];
  var clock = _m_['@yr/clock/index.js#1.1.8'];
  var Cursor = _m_['src/lib/cursor.js'];
  var Debug = _m_['debug/browser.js#2.2.0'];
  var Emitter = _m_['eventemitter3/index.js#1.2.0'];
  var isPlainObject = _m_['is-plain-obj/index.js#1.1.0'];
  var keys = _m_['@yr/keys/index.js#1.1.2'];
  var property = _m_['@yr/property/index.js#3.1.5'];
  var runtime = _m_['@yr/runtime/index.js#1.2.0'];
  var time = _m_['@yr/time/index.js#3.1.1'];
  
  var DEFAULT_LATENCY = 10000;
  var DEFAULT_LOAD_OPTIONS = {
    defaultExpiry: 600000,
    retry: 3,
    timeout: 5000
  };
  var DEFAULT_STORAGE_KEY_LENGTH = 2;
  var DEFAULT_SET_OPTIONS = {
    // Browser immutable by default
    immutable: runtime.isBrowser,
    reload: false,
    serialisable: true,
    merge: true
  };
  var DELEGATED_METHODS = ['get', 'link', 'set', 'unset', 'update', 'load', 'reload', 'cancelReload', 'upgradeStorageData'];
  var uid = 0;
  
  /**
   * Instance factory
   * @param {String} [id]
   * @param {Object} [data]
   * @param {Object} [options]
   * @returns {DataStore}
   */
  exports.create = function create(id, data, options) {
    return new DataStore(id, data, options);
  };
  
  var DataStore = function (_Emitter) {
    babelHelpers.inherits(DataStore, _Emitter);
  
    /**
     * Constructor
     * @param {String} [id]
     * @param {Object} [data]
     * @param {Object} [options]
     *  - handlers {Object} method:key
     *  - loading {Object}
     *    - defaultExpiry {Number}
     *    - namespaces {Array}
     *    - retry {Number}
     *    - timeout {Number}
     *  - serialisable {Object} key:Boolean
     *  - storage {Object}
     *    - keyLength {Number}
     *    - namespaces {Array}
     *    - store {Object}
     *  - writable {Boolean}
     */
  
    function DataStore(id) {
      var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      babelHelpers.classCallCheck(this, DataStore);
  
      var _this = babelHelpers.possibleConstructorReturn(this, _Emitter.call(this));
  
      _this.debug = Debug('yr:data' + (id ? ':' + id : ''));
      _this.destroyed = false;
      _this.id = id || 'store' + --uid;
      _this.writable = 'writable' in options ? options.writable : true;
  
      _this._cursors = {};
      _this._data = {};
      _this._handlers = options.handlers;
      _this._links = {};
      _this._loading = assign({
        active: {},
        namespaces: []
      }, DEFAULT_LOAD_OPTIONS, options.loading);
      _this._serialisable = options.serialisable || {};
      _this._storage = assign({
        keyLength: DEFAULT_STORAGE_KEY_LENGTH,
        namespaces: []
      }, options.storage);
  
      for (var _iterator = DELEGATED_METHODS, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;
  
        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }
  
        var method = _ref;
  
        var privateMethod = '_' + method;
  
        _this[method] = _this._route.bind(_this, privateMethod);
        _this[privateMethod] = _this[privateMethod].bind(_this);
      }
  
      _this.bootstrap(_this._storage, data);
      return _this;
    }
  
    /**
     * Bootstrap from 'storage' and/or 'data'
     * @param {Object} storage
     * @param {Object} data
     */
  
  
    DataStore.prototype.bootstrap = function bootstrap(storage, data) {
      var _this2 = this;
  
      // Bootstrap data
      var bootstrapOptions = { immutable: false };
  
      if (storage.store) {
        (function () {
          var namespaces = storage.namespaces;
          var store = storage.store;
  
          var storageData = namespaces.reduce(function (accumulatedStorageData, namespace) {
            var storageData = store.get(namespace);
  
            // Handle version mismatch
            if (store.shouldUpgrade(namespace)) {
              for (var key in storageData) {
                store.remove(key);
                // Allow handlers to override
                storageData[key] = _this2.upgradeStorageData(key, storageData[key]);
              }
            }
  
            return assign(accumulatedStorageData, storageData);
          }, {});
  
          _this2.set(storageData, null, bootstrapOptions);
          // Flatten data to force key length
          data = property.flatten(data, _this2._storage.keyLength);
        })();
      }
  
      this.set(data, null, bootstrapOptions);
    };
  
    /**
     * Determine if 'key' refers to a global property
     * @param {String} key
     * @returns {Boolean}
     */
  
  
    DataStore.prototype.isRootKey = function isRootKey(key) {
      return key ? key.charAt(0) == '/' : false;
    };
  
    /**
     * Retrieve global version of 'key',
     * taking account of nested status.
     * @param {String} key
     * @returns {String}
     */
  
  
    DataStore.prototype.getRootKey = function getRootKey() {
      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
  
      if (!this.isRootKey(key)) key = '/' + key;
      return key;
    };
  
    /**
     * Retrieve global version of 'key',
     * taking account of nested status.
     * @param {String} key
     * @returns {String}
     */
  
  
    DataStore.prototype.getStorageKey = function getStorageKey() {
      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
  
      if (keys.length(key) > this._storage.keyLength) key = keys.slice(key, 0, this._storage.keyLength);
      return key;
    };
  
    /**
     * Route 'method' to appropriate handler
     * depending on passed 'key' (args[0])
     * @param {String} method
     * @returns {Object|null}
     */
  
  
    DataStore.prototype._route = function _route(method) {
      var _this3 = this;
  
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
  
      var _args$ = args[0];
      var key = _args$ === undefined ? '' : _args$;
      var rest = args.slice(1);
  
  
      if (!key) return this[method].apply(this, args);
  
      if ('string' == typeof key) {
        if (key.charAt(0) == '/') key = key.slice(1);
  
        // Handle links
        if (key in this._links) key = this._links[key];
  
        var handler = keys.first(key);
        // Remove leading '_'
        var publicMethod = method.slice(1);
  
        // Route to handler if it exists
        if (handler && this._handlers && this._handlers[publicMethod] && handler in this._handlers[publicMethod]) {
          var _handlers$publicMetho;
  
          return (_handlers$publicMetho = this._handlers[publicMethod])[handler].apply(_handlers$publicMetho, [this, this[method], key].concat(rest));
        }
        return this[method].apply(this, [key].concat(rest));
      }
  
      // Batch (set, update, load, etc)
      if (isPlainObject(key)) {
        for (var k in key) {
          this._route.apply(this, [method, k, key[k]].concat(rest));
        }
        return;
      }
  
      // Array of keys (get, load)
      if (Array.isArray(key)) {
        return key.map(function (k) {
          return _this3._route.apply(_this3, [method, k].concat(rest));
        });
      }
    };
  
    /**
     * Retrieve property value with `key`
     * @param {String} [key]
     * @returns {Object}
     */
  
  
    DataStore.prototype._get = function _get(key) {
      // Return all if no key specified
      if (!key) return this._data;
  
      var value = property.get(key, this._data);
  
      // Check expiry
      if (Array.isArray(value)) {
        value.forEach(this._checkExpiry, this);
      } else {
        this._checkExpiry(value);
      }
  
      return value;
    };
  
    /**
     * Check if 'value' is expired
     * @param {Object} value
     */
  
  
    DataStore.prototype._checkExpiry = function _checkExpiry(value) {
      if (value && value.expires && time.now() > value.expires) {
        value.expired = true;
        value.expires = 0;
      }
    };
  
    /**
     * Store prop 'key' with 'value'
     * @param {String} key
     * @param {Object} value
     * @param {Object} [options]
     *  - immutable {Boolean}
     *  - reload {Boolean}
     *  - serialisable {Boolean}
     *  - merge {Boolean}
     * @returns {Object}
     */
  
  
    DataStore.prototype._set = function _set(key, value, options) {
      if (this.writable) {
        options = assign({}, DEFAULT_SET_OPTIONS, options);
  
        // Handle replacing underlying data
        if (key == null && isPlainObject(value)) {
          this.debug('reset');
          this._data = value;
          return;
        }
        // Handle removal of key
        if ('string' == typeof key && value == null) return this._unset(key);
  
        // Store serialisability
        if ('serialisable' in options) this.setSerialisable(key, options.serialisable);
  
        if (options.immutable) {
          // Returns null if no change
          var newData = property.set(key, value, this._data, options);
  
          if (newData !== null) {
            this._data = newData;
          } else {
            this.debug('WARNING no change after set "%s', key);
          }
        } else {
          property.set(key, value, this._data, options);
        }
  
        // Handle persistence
        // Allow options to override global config
        if ('persistent' in options && options.persistent || ~this._storage.namespaces.indexOf(key) || ~this._storage.namespaces.indexOf(keys.first(key))) {
          this._persist(key);
        }
      }
  
      return value;
    };
  
    /**
     * Remove 'key'
     * @param {String} key
     */
  
  
    DataStore.prototype._unset = function _unset(key) {
      var _this4 = this;
  
      // Remove prop from parent
      var length = keys.length(key);
      var k = length == 1 ? key : keys.last(key);
      var data = length == 1 ? this._data : this._get(keys.slice(key, 0, -1));
  
      // Only remove existing (prevent recursive trap)
      if (data && k in data) {
        (function () {
          var oldValue = data[k];
  
          _this4.debug('unset "%s"', key);
          delete data[k];
          // Prune dead links
          for (var toKey in _this4._links) {
            if (_this4._links[toKey] == key) {
              delete _this4._links[toKey];
            }
          }
  
          // Prune from storage
          if (~_this4._storage.namespaces.indexOf(key) || ~_this4._storage.namespaces.indexOf(keys.first(key))) {
            _this4._unpersist(key);
          }
  
          // Delay to prevent race condition (view render)
          clock.immediate(function () {
            _this4.emit('unset:' + key, null, oldValue);
            _this4.emit('unset', key, null, oldValue);
          });
        })();
      }
    };
  
    /**
     * Store prop 'key' with 'value', notifying listeners of change
     * Allows passing of arbitrary additional args to listeners
     * @param {String} key
     * @param {Object} value
     * @param {Object} options
     *  - immutable {Boolean}
     *  - reference {Boolean}
     *  - reload {Boolean}
     *  - serialisable {Boolean}
     *  - merge {Boolean}
     */
  
  
    DataStore.prototype._update = function _update(key, value) {
      for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        args[_key2 - 3] = arguments[_key2];
      }
  
      var _this5 = this;
  
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  
      if (this.writable) {
        (function () {
          _this5.debug('update %s', key);
          var oldValue = _this5.get(key);
  
          options.immutable = true;
          _this5.set(key, value, options);
  
          // Delay to prevent race condition
          clock.immediate(function () {
            _this5.emit.apply(_this5, ['update:' + key, value, oldValue, options].concat(args));
            _this5.emit.apply(_this5, ['update', key, value, oldValue, options].concat(args));
          });
        })();
      }
    };
  
    /**
     * Create link between 'fromKey' and 'toKey' keys
     * @param {String} fromKey
     * @param {String} toKey
     * @returns {Object}
     */
  
  
    DataStore.prototype._link = function _link(fromKey, toKey) {
      this._links[toKey] = fromKey;
      return this.get(fromKey);
    };
  
    /**
     * Load data from 'url' and store at 'key'
     * @param {String} key
     * @param {String} url
     * @param {Object} [options]
     *  - abort {Boolean}
     *  - ignoreQuery {Boolean}
     *  - immutable {Boolean}
     *  - isReload {Boolean}
     *  - reference {Boolean}
     *  - reload {Boolean}
     *  - serialisable {Boolean}
     *  - merge {Boolean}
     * @returns {Response}
     */
  
  
    DataStore.prototype._load = function _load(key, url) {
      var _this6 = this;
  
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  
      var req = agent.get(url, options);
  
      if (!this._loading.active[key]) {
        this.debug('load %s from %s', key, url);
  
        this._loading.active[key] = true;
  
        req.timeout(this._loading.timeout).retry(this._loading.retry).end(function (err, res) {
          delete _this6._loading.active[key];
  
          if (err) {
            _this6.debug('remote resource "%s" not found at %s', key, url);
            // Remove if no longer found
            if (err.status < 500) _this6.unset(key);
          } else {
            (function () {
              _this6.debug('loaded "%s" in %dms', key, res.duration);
  
              var expires = 0;
              var value = void 0;
  
              // Guard against empty data
              if (res.body) {
                // Handle locations results separately
                var data = 'totalResults' in res.body ? res.body._embedded && res.body._embedded.location || [] : res.body;
  
                // Add expires header
                if (res.headers && 'expires' in res.headers) {
                  expires = getExpiry(res.headers.expires, _this6._loading.defaultExpiry);
  
                  if (Array.isArray(data)) {
                    data.forEach(function (d) {
                      if (isPlainObject(d)) {
                        d.expires = expires;
                        d.expired = false;
                      }
                    });
                  } else {
                    data.expires = expires;
                    data.expired = false;
                  }
                }
                value = _this6.set(key, data, options);
              }
  
              _this6.emit('load:' + key, value);
              _this6.emit('load', key, value);
              if (options.isReload) {
                _this6.emit('reload:' + key, value);
                _this6.emit('reload', key, value);
              }
            })();
          }
  
          // Allow options to override global config
          if ('reload' in options && options.reload || ~_this6._loading.namespaces.indexOf(key) || ~_this6._loading.namespaces.indexOf(keys.first(key))) {
            _this6._reload(key, url, options);
          }
        });
      }
  
      return req;
    };
  
    /**
     * Reload data from 'url'
     * @param {String} key
     * @param {String} url
     * @param {Object} [options]
     *  - abort {Boolean}
     *  - ignoreQuery {Boolean}
     *  - immutable {Boolean}
     *  - isReload {Boolean}
     *  - reference {Boolean}
     *  - reload {Boolean}
     *  - serialisable {Boolean}
     *  - merge {Boolean}
     * @returns {null}
     */
  
  
    DataStore.prototype._reload = function _reload(key, url, options) {
      var _this7 = this;
  
      // Already expired
      if (this.get(key + '/expired')) return this.load(key, url, options);
  
      var duration = (this.get(key + '/expires') || 0) - time.now();
  
      // Guard against invalid duration (reload on error with old or missing expiry, etc)
      if (duration <= 0) duration = this._loading.defaultExpiry;
  
      options = assign({}, options, { isReload: true });
      this.debug('reloading "%s" in %dms', key, duration);
      clock.timeout(duration, function () {
        _this7.load(key, url, options);
      }, key);
    };
  
    /**
     * Cancel any existing reload timeouts
     * @param {String} key
     */
  
  
    DataStore.prototype._cancelReload = function _cancelReload(key) {
      clock.cancel(key);
    };
  
    /**
     * Save to local storage
     * @param {String} key
     */
  
  
    DataStore.prototype._persist = function _persist(key) {
      if (this._storage.store) {
        key = this.getStorageKey(key);
        this._storage.store.set(key, this.toJSON(key));
      }
    };
  
    /**
     * Remove from local storage
     * @param {String} key
     */
  
  
    DataStore.prototype._unpersist = function _unpersist(key) {
      if (this._storage.store) {
        this._storage.store.remove(this.getStorageKey(key));
      }
    };
  
    /**
     * Update storage when versions don't match
     * @param {String} key
     * @param {Object} value
     * @returns {Object}
     */
  
  
    DataStore.prototype._upgradeStorageData = function _upgradeStorageData(key, value) {
      // Delete as default
      return null;
    };
  
    /**
     * Retrieve an instance reference at 'key' to a subset of data
     * @param {String} key
     * @returns {DataStore}
     */
  
  
    DataStore.prototype.createCursor = function createCursor(key) {
      key = this.getRootKey(key);
  
      var cursor = this._cursors[key];
  
      // Create and store
      if (!cursor) {
        cursor = Cursor.create(key, this);
        this._cursors[key] = cursor;
      }
  
      return cursor;
    };
  
    /**
     * Store serialisability of 'key'
     * @param {String} key
     * @param {Boolean} value
     */
  
  
    DataStore.prototype.setSerialisable = function setSerialisable(key, value) {
      if (this.isRootKey(key)) key = key.slice(1);
  
      if (isPlainObject(key)) {
        for (var k in key) {
          this.setSerialisable(k, value);
        }
      }
  
      this._serialisable[key] = value;
    };
  
    /**
     * Destroy instance
     */
  
  
    DataStore.prototype.destroy = function destroy() {
      // Destroy cursors
      for (var key in this._cursors) {
        this._cursors[key].destroy();
      }
      this._cursors = {};
      this._data = {};
      this._handlers = {};
      this._links = {};
      this._loading = {};
      this._serialisable = {};
      this._storage = {};
      this.destroyed = true;
      this.removeAllListeners();
      clock.cancel(this.id);
    };
  
    /**
     * Dump all data, optionally stringified
     * @param {Boolean} stringify
     * @returns {Object|String}
     */
  
  
    DataStore.prototype.dump = function dump(stringify) {
      var obj = {};
  
      for (var prop in this._data) {
        obj[prop] = this._data[prop];
      }
  
      if (stringify) {
        try {
          return JSON.stringify(obj);
        } catch (err) {
          return '';
        }
      }
  
      return obj;
    };
  
    /**
     * Prepare for serialisation
     * @param {String} [key]
     * @returns {Object}
     */
  
  
    DataStore.prototype.toJSON = function toJSON(key) {
      if (key) return this._serialise(key, this.get(key));
      return this._serialise(null, this._data);
    };
  
    /**
     * Retrieve serialisable 'data'
     * @param {String} key
     * @param {Object} data
     * @returns {Object}
     */
  
  
    DataStore.prototype._serialise = function _serialise(key, data) {
      // Add data props
      if (isPlainObject(data)) {
        var obj = {};
        var keyChain = void 0;
  
        for (var prop in data) {
          keyChain = key ? key + '/' + prop : prop;
  
          if (this._serialisable[keyChain] !== false) {
            if (isPlainObject(data[prop])) {
              obj[prop] = this._serialise(keyChain, data[prop]);
            } else if (time.isTime(data[prop])) {
              obj[prop] = data[prop].toJSON();
            } else {
              obj[prop] = data[prop];
            }
          }
        }
  
        return obj;
      }
  
      return this._serialisable[key] !== false ? data : null;
    };
  
    return DataStore;
  }(Emitter);
  
  /**
   * Retrieve expiry from 'timestamp'
   * @param {Number} timestamp
   * @param {Number} minimum
   * @returns {Number}
   */
  
  
  function getExpiry(timestamp, minimum) {
    // Add latency overhead to compensate for transmition time
    var expires = timestamp + DEFAULT_LATENCY;
    var now = time.now();
  
    return expires > now ? expires
    // Local clock is set incorrectly
    : now + minimum;
  }

  return module.exports;
}).call({exports:{}});